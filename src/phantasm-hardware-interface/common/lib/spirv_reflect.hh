#pragma once

// NOTE: the version history below is not properly maintained
// this is commit bf64751356592b1d1d685ae00548a612b47bbea0
// as of 29.10.2020

/*
 Copyright 2017-2018 Google Inc.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/*

VERSION HISTORY

  1.0   (2018-03-27) Initial public release

*/

/*!

 @file spirv_reflect.h

*/
#ifndef SPIRV_REFLECT_H
#define SPIRV_REFLECT_H

/*
** Copyright (c) 2014-2018 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and/or associated documentation files (the "Materials"),
** to deal in the Materials without restriction, including without limitation
** the rights to use, copy, modify, merge, publish, distribute, sublicense,
** and/or sell copies of the Materials, and to permit persons to whom the
** Materials are furnished to do so, subject to the following conditions:
**
** The above copyright notice and this permission notice shall be included in
** all copies or substantial portions of the Materials.
**
** MODIFICATIONS TO THIS FILE MAY MEAN IT NO LONGER ACCURATELY REFLECTS KHRONOS
** STANDARDS. THE UNMODIFIED, NORMATIVE VERSIONS OF KHRONOS SPECIFICATIONS AND
** HEADER INFORMATION ARE LOCATED AT https://www.khronos.org/registry/
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
** THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
** FROM,OUT OF OR IN CONNECTION WITH THE MATERIALS OR THE USE OR OTHER DEALINGS
** IN THE MATERIALS.
*/

/*
** This header is automatically generated by the same tool that creates
** the Binary Section of the SPIR-V specification.
*/

/*
** Enumeration tokens for SPIR-V, in various styles:
**   C, C++, C++11, JSON, Lua, Python
**
** - C will have tokens with a "Spv" prefix, e.g.: SpvSourceLanguageGLSL
** - C++ will have tokens in the "spv" name space, e.g.: spv::SourceLanguageGLSL
** - C++11 will use enum classes in the spv namespace, e.g.: spv::SourceLanguage::GLSL
** - Lua will use tables, e.g.: spv.SourceLanguage.GLSL
** - Python will use dictionaries, e.g.: spv['SourceLanguage']['GLSL']
**
** Some tokens act like mask values, which can be OR'd together,
** while others are mutually exclusive.  The mask-like ones have
** "Mask" in their name, and a parallel enum that has the shift
** amount (1 << x) for each corresponding enumerant.
*/

#ifndef spirv_H
#define spirv_H

typedef unsigned int SpvId;

#define SPV_VERSION 0x10300
#define SPV_REVISION 1

static const unsigned int SpvMagicNumber = 0x07230203;
static const unsigned int SpvVersion = 0x00010300;
static const unsigned int SpvRevision = 1;
static const unsigned int SpvOpCodeMask = 0xffff;
static const unsigned int SpvWordCountShift = 16;

typedef enum SpvSourceLanguage_
{
    SpvSourceLanguageUnknown = 0,
    SpvSourceLanguageESSL = 1,
    SpvSourceLanguageGLSL = 2,
    SpvSourceLanguageOpenCL_C = 3,
    SpvSourceLanguageOpenCL_CPP = 4,
    SpvSourceLanguageHLSL = 5,
    SpvSourceLanguageMax = 0x7fffffff,
} SpvSourceLanguage;

typedef enum SpvExecutionModel_
{
    SpvExecutionModelVertex = 0,
    SpvExecutionModelTessellationControl = 1,
    SpvExecutionModelTessellationEvaluation = 2,
    SpvExecutionModelGeometry = 3,
    SpvExecutionModelFragment = 4,
    SpvExecutionModelGLCompute = 5,
    SpvExecutionModelKernel = 6,
    // SPV_NV_ray_tracing
    SpvExecutionModelRayGenerationNV = 5313,
    SpvExecutionModelIntersectionNV = 5314,
    SpvExecutionModelAnyHitNV = 5315,
    SpvExecutionModelClosestHitNV = 5316,
    SpvExecutionModelMissNV = 5317,
    SpvExecutionModelCallableNV = 5318,
    // end of SPV_NV_ray_tracing
    SpvExecutionModelMax = 0x7fffffff,
} SpvExecutionModel;

typedef enum SpvAddressingModel_
{
    SpvAddressingModelLogical = 0,
    SpvAddressingModelPhysical32 = 1,
    SpvAddressingModelPhysical64 = 2,
    SpvAddressingModelMax = 0x7fffffff,
} SpvAddressingModel;

typedef enum SpvMemoryModel_
{
    SpvMemoryModelSimple = 0,
    SpvMemoryModelGLSL450 = 1,
    SpvMemoryModelOpenCL = 2,
    SpvMemoryModelMax = 0x7fffffff,
} SpvMemoryModel;

typedef enum SpvExecutionMode_
{
    SpvExecutionModeInvocations = 0,
    SpvExecutionModeSpacingEqual = 1,
    SpvExecutionModeSpacingFractionalEven = 2,
    SpvExecutionModeSpacingFractionalOdd = 3,
    SpvExecutionModeVertexOrderCw = 4,
    SpvExecutionModeVertexOrderCcw = 5,
    SpvExecutionModePixelCenterInteger = 6,
    SpvExecutionModeOriginUpperLeft = 7,
    SpvExecutionModeOriginLowerLeft = 8,
    SpvExecutionModeEarlyFragmentTests = 9,
    SpvExecutionModePointMode = 10,
    SpvExecutionModeXfb = 11,
    SpvExecutionModeDepthReplacing = 12,
    SpvExecutionModeDepthGreater = 14,
    SpvExecutionModeDepthLess = 15,
    SpvExecutionModeDepthUnchanged = 16,
    SpvExecutionModeLocalSize = 17,
    SpvExecutionModeLocalSizeHint = 18,
    SpvExecutionModeInputPoints = 19,
    SpvExecutionModeInputLines = 20,
    SpvExecutionModeInputLinesAdjacency = 21,
    SpvExecutionModeTriangles = 22,
    SpvExecutionModeInputTrianglesAdjacency = 23,
    SpvExecutionModeQuads = 24,
    SpvExecutionModeIsolines = 25,
    SpvExecutionModeOutputVertices = 26,
    SpvExecutionModeOutputPoints = 27,
    SpvExecutionModeOutputLineStrip = 28,
    SpvExecutionModeOutputTriangleStrip = 29,
    SpvExecutionModeVecTypeHint = 30,
    SpvExecutionModeContractionOff = 31,
    SpvExecutionModeInitializer = 33,
    SpvExecutionModeFinalizer = 34,
    SpvExecutionModeSubgroupSize = 35,
    SpvExecutionModeSubgroupsPerWorkgroup = 36,
    SpvExecutionModeSubgroupsPerWorkgroupId = 37,
    SpvExecutionModeLocalSizeId = 38,
    SpvExecutionModeLocalSizeHintId = 39,
    SpvExecutionModePostDepthCoverage = 4446,
    SpvExecutionModeStencilRefReplacingEXT = 5027,
    SpvExecutionModeMax = 0x7fffffff,
} SpvExecutionMode;

typedef enum SpvStorageClass_
{
    SpvStorageClassUniformConstant = 0,
    SpvStorageClassInput = 1,
    SpvStorageClassUniform = 2,
    SpvStorageClassOutput = 3,
    SpvStorageClassWorkgroup = 4,
    SpvStorageClassCrossWorkgroup = 5,
    SpvStorageClassPrivate = 6,
    SpvStorageClassFunction = 7,
    SpvStorageClassGeneric = 8,
    SpvStorageClassPushConstant = 9,
    SpvStorageClassAtomicCounter = 10,
    SpvStorageClassImage = 11,
    SpvStorageClassStorageBuffer = 12,
    // SPV_NV_ray_tracing
    SpvStorageClassCallableDataNV = 5328,
    SpvStorageClassIncomingCallableDataNV = 5329,
    SpvStorageClassRayPayloadNV = 5338,
    SpvStorageClassHitAttributeNV = 5339,
    SpvStorageClassIncomingRayPayloadNV = 5342,
    SpvStorageClassShaderRecordBufferNV = 5343,
    // end of SPV_NV_ray_tracing
    SpvStorageClassMax = 0x7fffffff,
} SpvStorageClass;

typedef enum SpvDim_
{
    SpvDim1D = 0,
    SpvDim2D = 1,
    SpvDim3D = 2,
    SpvDimCube = 3,
    SpvDimRect = 4,
    SpvDimBuffer = 5,
    SpvDimSubpassData = 6,
    SpvDimMax = 0x7fffffff,
} SpvDim;

typedef enum SpvSamplerAddressingMode_
{
    SpvSamplerAddressingModeNone = 0,
    SpvSamplerAddressingModeClampToEdge = 1,
    SpvSamplerAddressingModeClamp = 2,
    SpvSamplerAddressingModeRepeat = 3,
    SpvSamplerAddressingModeRepeatMirrored = 4,
    SpvSamplerAddressingModeMax = 0x7fffffff,
} SpvSamplerAddressingMode;

typedef enum SpvSamplerFilterMode_
{
    SpvSamplerFilterModeNearest = 0,
    SpvSamplerFilterModeLinear = 1,
    SpvSamplerFilterModeMax = 0x7fffffff,
} SpvSamplerFilterMode;

typedef enum SpvImageFormat_
{
    SpvImageFormatUnknown = 0,
    SpvImageFormatRgba32f = 1,
    SpvImageFormatRgba16f = 2,
    SpvImageFormatR32f = 3,
    SpvImageFormatRgba8 = 4,
    SpvImageFormatRgba8Snorm = 5,
    SpvImageFormatRg32f = 6,
    SpvImageFormatRg16f = 7,
    SpvImageFormatR11fG11fB10f = 8,
    SpvImageFormatR16f = 9,
    SpvImageFormatRgba16 = 10,
    SpvImageFormatRgb10A2 = 11,
    SpvImageFormatRg16 = 12,
    SpvImageFormatRg8 = 13,
    SpvImageFormatR16 = 14,
    SpvImageFormatR8 = 15,
    SpvImageFormatRgba16Snorm = 16,
    SpvImageFormatRg16Snorm = 17,
    SpvImageFormatRg8Snorm = 18,
    SpvImageFormatR16Snorm = 19,
    SpvImageFormatR8Snorm = 20,
    SpvImageFormatRgba32i = 21,
    SpvImageFormatRgba16i = 22,
    SpvImageFormatRgba8i = 23,
    SpvImageFormatR32i = 24,
    SpvImageFormatRg32i = 25,
    SpvImageFormatRg16i = 26,
    SpvImageFormatRg8i = 27,
    SpvImageFormatR16i = 28,
    SpvImageFormatR8i = 29,
    SpvImageFormatRgba32ui = 30,
    SpvImageFormatRgba16ui = 31,
    SpvImageFormatRgba8ui = 32,
    SpvImageFormatR32ui = 33,
    SpvImageFormatRgb10a2ui = 34,
    SpvImageFormatRg32ui = 35,
    SpvImageFormatRg16ui = 36,
    SpvImageFormatRg8ui = 37,
    SpvImageFormatR16ui = 38,
    SpvImageFormatR8ui = 39,
    SpvImageFormatMax = 0x7fffffff,
} SpvImageFormat;

typedef enum SpvImageChannelOrder_
{
    SpvImageChannelOrderR = 0,
    SpvImageChannelOrderA = 1,
    SpvImageChannelOrderRG = 2,
    SpvImageChannelOrderRA = 3,
    SpvImageChannelOrderRGB = 4,
    SpvImageChannelOrderRGBA = 5,
    SpvImageChannelOrderBGRA = 6,
    SpvImageChannelOrderARGB = 7,
    SpvImageChannelOrderIntensity = 8,
    SpvImageChannelOrderLuminance = 9,
    SpvImageChannelOrderRx = 10,
    SpvImageChannelOrderRGx = 11,
    SpvImageChannelOrderRGBx = 12,
    SpvImageChannelOrderDepth = 13,
    SpvImageChannelOrderDepthStencil = 14,
    SpvImageChannelOrdersRGB = 15,
    SpvImageChannelOrdersRGBx = 16,
    SpvImageChannelOrdersRGBA = 17,
    SpvImageChannelOrdersBGRA = 18,
    SpvImageChannelOrderABGR = 19,
    SpvImageChannelOrderMax = 0x7fffffff,
} SpvImageChannelOrder;

typedef enum SpvImageChannelDataType_
{
    SpvImageChannelDataTypeSnormInt8 = 0,
    SpvImageChannelDataTypeSnormInt16 = 1,
    SpvImageChannelDataTypeUnormInt8 = 2,
    SpvImageChannelDataTypeUnormInt16 = 3,
    SpvImageChannelDataTypeUnormShort565 = 4,
    SpvImageChannelDataTypeUnormShort555 = 5,
    SpvImageChannelDataTypeUnormInt101010 = 6,
    SpvImageChannelDataTypeSignedInt8 = 7,
    SpvImageChannelDataTypeSignedInt16 = 8,
    SpvImageChannelDataTypeSignedInt32 = 9,
    SpvImageChannelDataTypeUnsignedInt8 = 10,
    SpvImageChannelDataTypeUnsignedInt16 = 11,
    SpvImageChannelDataTypeUnsignedInt32 = 12,
    SpvImageChannelDataTypeHalfFloat = 13,
    SpvImageChannelDataTypeFloat = 14,
    SpvImageChannelDataTypeUnormInt24 = 15,
    SpvImageChannelDataTypeUnormInt101010_2 = 16,
    SpvImageChannelDataTypeMax = 0x7fffffff,
} SpvImageChannelDataType;

typedef enum SpvImageOperandsShift_
{
    SpvImageOperandsBiasShift = 0,
    SpvImageOperandsLodShift = 1,
    SpvImageOperandsGradShift = 2,
    SpvImageOperandsConstOffsetShift = 3,
    SpvImageOperandsOffsetShift = 4,
    SpvImageOperandsConstOffsetsShift = 5,
    SpvImageOperandsSampleShift = 6,
    SpvImageOperandsMinLodShift = 7,
    SpvImageOperandsMax = 0x7fffffff,
} SpvImageOperandsShift;

typedef enum SpvImageOperandsMask_
{
    SpvImageOperandsMaskNone = 0,
    SpvImageOperandsBiasMask = 0x00000001,
    SpvImageOperandsLodMask = 0x00000002,
    SpvImageOperandsGradMask = 0x00000004,
    SpvImageOperandsConstOffsetMask = 0x00000008,
    SpvImageOperandsOffsetMask = 0x00000010,
    SpvImageOperandsConstOffsetsMask = 0x00000020,
    SpvImageOperandsSampleMask = 0x00000040,
    SpvImageOperandsMinLodMask = 0x00000080,
} SpvImageOperandsMask;

typedef enum SpvFPFastMathModeShift_
{
    SpvFPFastMathModeNotNaNShift = 0,
    SpvFPFastMathModeNotInfShift = 1,
    SpvFPFastMathModeNSZShift = 2,
    SpvFPFastMathModeAllowRecipShift = 3,
    SpvFPFastMathModeFastShift = 4,
    SpvFPFastMathModeMax = 0x7fffffff,
} SpvFPFastMathModeShift;

typedef enum SpvFPFastMathModeMask_
{
    SpvFPFastMathModeMaskNone = 0,
    SpvFPFastMathModeNotNaNMask = 0x00000001,
    SpvFPFastMathModeNotInfMask = 0x00000002,
    SpvFPFastMathModeNSZMask = 0x00000004,
    SpvFPFastMathModeAllowRecipMask = 0x00000008,
    SpvFPFastMathModeFastMask = 0x00000010,
} SpvFPFastMathModeMask;

typedef enum SpvFPRoundingMode_
{
    SpvFPRoundingModeRTE = 0,
    SpvFPRoundingModeRTZ = 1,
    SpvFPRoundingModeRTP = 2,
    SpvFPRoundingModeRTN = 3,
    SpvFPRoundingModeMax = 0x7fffffff,
} SpvFPRoundingMode;

typedef enum SpvLinkageType_
{
    SpvLinkageTypeExport = 0,
    SpvLinkageTypeImport = 1,
    SpvLinkageTypeMax = 0x7fffffff,
} SpvLinkageType;

typedef enum SpvAccessQualifier_
{
    SpvAccessQualifierReadOnly = 0,
    SpvAccessQualifierWriteOnly = 1,
    SpvAccessQualifierReadWrite = 2,
    SpvAccessQualifierMax = 0x7fffffff,
} SpvAccessQualifier;

typedef enum SpvFunctionParameterAttribute_
{
    SpvFunctionParameterAttributeZext = 0,
    SpvFunctionParameterAttributeSext = 1,
    SpvFunctionParameterAttributeByVal = 2,
    SpvFunctionParameterAttributeSret = 3,
    SpvFunctionParameterAttributeNoAlias = 4,
    SpvFunctionParameterAttributeNoCapture = 5,
    SpvFunctionParameterAttributeNoWrite = 6,
    SpvFunctionParameterAttributeNoReadWrite = 7,
    SpvFunctionParameterAttributeMax = 0x7fffffff,
} SpvFunctionParameterAttribute;

typedef enum SpvDecoration_
{
    SpvDecorationRelaxedPrecision = 0,
    SpvDecorationSpecId = 1,
    SpvDecorationBlock = 2,
    SpvDecorationBufferBlock = 3,
    SpvDecorationRowMajor = 4,
    SpvDecorationColMajor = 5,
    SpvDecorationArrayStride = 6,
    SpvDecorationMatrixStride = 7,
    SpvDecorationGLSLShared = 8,
    SpvDecorationGLSLPacked = 9,
    SpvDecorationCPacked = 10,
    SpvDecorationBuiltIn = 11,
    SpvDecorationNoPerspective = 13,
    SpvDecorationFlat = 14,
    SpvDecorationPatch = 15,
    SpvDecorationCentroid = 16,
    SpvDecorationSample = 17,
    SpvDecorationInvariant = 18,
    SpvDecorationRestrict = 19,
    SpvDecorationAliased = 20,
    SpvDecorationVolatile = 21,
    SpvDecorationConstant = 22,
    SpvDecorationCoherent = 23,
    SpvDecorationNonWritable = 24,
    SpvDecorationNonReadable = 25,
    SpvDecorationUniform = 26,
    SpvDecorationSaturatedConversion = 28,
    SpvDecorationStream = 29,
    SpvDecorationLocation = 30,
    SpvDecorationComponent = 31,
    SpvDecorationIndex = 32,
    SpvDecorationBinding = 33,
    SpvDecorationDescriptorSet = 34,
    SpvDecorationOffset = 35,
    SpvDecorationXfbBuffer = 36,
    SpvDecorationXfbStride = 37,
    SpvDecorationFuncParamAttr = 38,
    SpvDecorationFPRoundingMode = 39,
    SpvDecorationFPFastMathMode = 40,
    SpvDecorationLinkageAttributes = 41,
    SpvDecorationNoContraction = 42,
    SpvDecorationInputAttachmentIndex = 43,
    SpvDecorationAlignment = 44,
    SpvDecorationMaxByteOffset = 45,
    SpvDecorationAlignmentId = 46,
    SpvDecorationMaxByteOffsetId = 47,
    SpvDecorationExplicitInterpAMD = 4999,
    SpvDecorationOverrideCoverageNV = 5248,
    SpvDecorationPassthroughNV = 5250,
    SpvDecorationViewportRelativeNV = 5252,
    SpvDecorationSecondaryViewportRelativeNV = 5256,
    // SPV_NV_ray_tracing
    SpvDecorationLaunchIdNV = 5319,
    SpvDecorationLaunchSizeNV = 5320,
    SpvDecorationWorldRayOriginNV = 5321,
    SpvDecorationWorldRayDirectionNV = 5322,
    SpvDecorationObjectRayOriginNV = 5323,
    SpvDecorationObjectRayDirectionNV = 5324,
    SpvDecorationRayTminNV = 5325,
    SpvDecorationRayTmaxNV = 5326,
    SpvDecorationInstanceCustomIndexNV = 5327,
    SpvDecorationObjectToWorldNV = 5330,
    SpvDecorationWorldToObjectNV = 5331,
    SpvDecorationHitTNV = 5332,
    SpvDecorationHitKindNV = 5333,
    SpvDecorationIncomingRayFlagsNV = 5351,
    // end of SPV_NV_ray_tracing
    SpvDecorationHlslCounterBufferGOOGLE = 5634,
    SpvDecorationHlslSemanticGOOGLE = 5635,
    SpvDecorationMax = 0x7fffffff,
} SpvDecoration;

typedef enum SpvBuiltIn_
{
    SpvBuiltInPosition = 0,
    SpvBuiltInPointSize = 1,
    SpvBuiltInClipDistance = 3,
    SpvBuiltInCullDistance = 4,
    SpvBuiltInVertexId = 5,
    SpvBuiltInInstanceId = 6,
    SpvBuiltInPrimitiveId = 7,
    SpvBuiltInInvocationId = 8,
    SpvBuiltInLayer = 9,
    SpvBuiltInViewportIndex = 10,
    SpvBuiltInTessLevelOuter = 11,
    SpvBuiltInTessLevelInner = 12,
    SpvBuiltInTessCoord = 13,
    SpvBuiltInPatchVertices = 14,
    SpvBuiltInFragCoord = 15,
    SpvBuiltInPointCoord = 16,
    SpvBuiltInFrontFacing = 17,
    SpvBuiltInSampleId = 18,
    SpvBuiltInSamplePosition = 19,
    SpvBuiltInSampleMask = 20,
    SpvBuiltInFragDepth = 22,
    SpvBuiltInHelperInvocation = 23,
    SpvBuiltInNumWorkgroups = 24,
    SpvBuiltInWorkgroupSize = 25,
    SpvBuiltInWorkgroupId = 26,
    SpvBuiltInLocalInvocationId = 27,
    SpvBuiltInGlobalInvocationId = 28,
    SpvBuiltInLocalInvocationIndex = 29,
    SpvBuiltInWorkDim = 30,
    SpvBuiltInGlobalSize = 31,
    SpvBuiltInEnqueuedWorkgroupSize = 32,
    SpvBuiltInGlobalOffset = 33,
    SpvBuiltInGlobalLinearId = 34,
    SpvBuiltInSubgroupSize = 36,
    SpvBuiltInSubgroupMaxSize = 37,
    SpvBuiltInNumSubgroups = 38,
    SpvBuiltInNumEnqueuedSubgroups = 39,
    SpvBuiltInSubgroupId = 40,
    SpvBuiltInSubgroupLocalInvocationId = 41,
    SpvBuiltInVertexIndex = 42,
    SpvBuiltInInstanceIndex = 43,
    SpvBuiltInSubgroupEqMask = 4416,
    SpvBuiltInSubgroupEqMaskKHR = 4416,
    SpvBuiltInSubgroupGeMask = 4417,
    SpvBuiltInSubgroupGeMaskKHR = 4417,
    SpvBuiltInSubgroupGtMask = 4418,
    SpvBuiltInSubgroupGtMaskKHR = 4418,
    SpvBuiltInSubgroupLeMask = 4419,
    SpvBuiltInSubgroupLeMaskKHR = 4419,
    SpvBuiltInSubgroupLtMask = 4420,
    SpvBuiltInSubgroupLtMaskKHR = 4420,
    SpvBuiltInBaseVertex = 4424,
    SpvBuiltInBaseInstance = 4425,
    SpvBuiltInDrawIndex = 4426,
    SpvBuiltInDeviceIndex = 4438,
    SpvBuiltInViewIndex = 4440,
    SpvBuiltInBaryCoordNoPerspAMD = 4992,
    SpvBuiltInBaryCoordNoPerspCentroidAMD = 4993,
    SpvBuiltInBaryCoordNoPerspSampleAMD = 4994,
    SpvBuiltInBaryCoordSmoothAMD = 4995,
    SpvBuiltInBaryCoordSmoothCentroidAMD = 4996,
    SpvBuiltInBaryCoordSmoothSampleAMD = 4997,
    SpvBuiltInBaryCoordPullModelAMD = 4998,
    SpvBuiltInFragStencilRefEXT = 5014,
    SpvBuiltInViewportMaskNV = 5253,
    SpvBuiltInSecondaryPositionNV = 5257,
    SpvBuiltInSecondaryViewportMaskNV = 5258,
    SpvBuiltInPositionPerViewNV = 5261,
    SpvBuiltInViewportMaskPerViewNV = 5262,
    SpvBuiltInFullyCoveredEXT = 5264,
    SpvBuiltInMax = 0x7fffffff,
} SpvBuiltIn;

typedef enum SpvSelectionControlShift_
{
    SpvSelectionControlFlattenShift = 0,
    SpvSelectionControlDontFlattenShift = 1,
    SpvSelectionControlMax = 0x7fffffff,
} SpvSelectionControlShift;

typedef enum SpvSelectionControlMask_
{
    SpvSelectionControlMaskNone = 0,
    SpvSelectionControlFlattenMask = 0x00000001,
    SpvSelectionControlDontFlattenMask = 0x00000002,
} SpvSelectionControlMask;

typedef enum SpvLoopControlShift_
{
    SpvLoopControlUnrollShift = 0,
    SpvLoopControlDontUnrollShift = 1,
    SpvLoopControlDependencyInfiniteShift = 2,
    SpvLoopControlDependencyLengthShift = 3,
    SpvLoopControlMax = 0x7fffffff,
} SpvLoopControlShift;

typedef enum SpvLoopControlMask_
{
    SpvLoopControlMaskNone = 0,
    SpvLoopControlUnrollMask = 0x00000001,
    SpvLoopControlDontUnrollMask = 0x00000002,
    SpvLoopControlDependencyInfiniteMask = 0x00000004,
    SpvLoopControlDependencyLengthMask = 0x00000008,
} SpvLoopControlMask;

typedef enum SpvFunctionControlShift_
{
    SpvFunctionControlInlineShift = 0,
    SpvFunctionControlDontInlineShift = 1,
    SpvFunctionControlPureShift = 2,
    SpvFunctionControlConstShift = 3,
    SpvFunctionControlMax = 0x7fffffff,
} SpvFunctionControlShift;

typedef enum SpvFunctionControlMask_
{
    SpvFunctionControlMaskNone = 0,
    SpvFunctionControlInlineMask = 0x00000001,
    SpvFunctionControlDontInlineMask = 0x00000002,
    SpvFunctionControlPureMask = 0x00000004,
    SpvFunctionControlConstMask = 0x00000008,
} SpvFunctionControlMask;

typedef enum SpvMemorySemanticsShift_
{
    SpvMemorySemanticsAcquireShift = 1,
    SpvMemorySemanticsReleaseShift = 2,
    SpvMemorySemanticsAcquireReleaseShift = 3,
    SpvMemorySemanticsSequentiallyConsistentShift = 4,
    SpvMemorySemanticsUniformMemoryShift = 6,
    SpvMemorySemanticsSubgroupMemoryShift = 7,
    SpvMemorySemanticsWorkgroupMemoryShift = 8,
    SpvMemorySemanticsCrossWorkgroupMemoryShift = 9,
    SpvMemorySemanticsAtomicCounterMemoryShift = 10,
    SpvMemorySemanticsImageMemoryShift = 11,
    SpvMemorySemanticsMax = 0x7fffffff,
} SpvMemorySemanticsShift;

typedef enum SpvMemorySemanticsMask_
{
    SpvMemorySemanticsMaskNone = 0,
    SpvMemorySemanticsAcquireMask = 0x00000002,
    SpvMemorySemanticsReleaseMask = 0x00000004,
    SpvMemorySemanticsAcquireReleaseMask = 0x00000008,
    SpvMemorySemanticsSequentiallyConsistentMask = 0x00000010,
    SpvMemorySemanticsUniformMemoryMask = 0x00000040,
    SpvMemorySemanticsSubgroupMemoryMask = 0x00000080,
    SpvMemorySemanticsWorkgroupMemoryMask = 0x00000100,
    SpvMemorySemanticsCrossWorkgroupMemoryMask = 0x00000200,
    SpvMemorySemanticsAtomicCounterMemoryMask = 0x00000400,
    SpvMemorySemanticsImageMemoryMask = 0x00000800,
} SpvMemorySemanticsMask;

typedef enum SpvMemoryAccessShift_
{
    SpvMemoryAccessVolatileShift = 0,
    SpvMemoryAccessAlignedShift = 1,
    SpvMemoryAccessNontemporalShift = 2,
    SpvMemoryAccessMax = 0x7fffffff,
} SpvMemoryAccessShift;

typedef enum SpvMemoryAccessMask_
{
    SpvMemoryAccessMaskNone = 0,
    SpvMemoryAccessVolatileMask = 0x00000001,
    SpvMemoryAccessAlignedMask = 0x00000002,
    SpvMemoryAccessNontemporalMask = 0x00000004,
} SpvMemoryAccessMask;

typedef enum SpvScope_
{
    SpvScopeCrossDevice = 0,
    SpvScopeDevice = 1,
    SpvScopeWorkgroup = 2,
    SpvScopeSubgroup = 3,
    SpvScopeInvocation = 4,
    SpvScopeMax = 0x7fffffff,
} SpvScope;

typedef enum SpvGroupOperation_
{
    SpvGroupOperationReduce = 0,
    SpvGroupOperationInclusiveScan = 1,
    SpvGroupOperationExclusiveScan = 2,
    SpvGroupOperationClusteredReduce = 3,
    SpvGroupOperationPartitionedReduceNV = 6,
    SpvGroupOperationPartitionedInclusiveScanNV = 7,
    SpvGroupOperationPartitionedExclusiveScanNV = 8,
    SpvGroupOperationMax = 0x7fffffff,
} SpvGroupOperation;

typedef enum SpvKernelEnqueueFlags_
{
    SpvKernelEnqueueFlagsNoWait = 0,
    SpvKernelEnqueueFlagsWaitKernel = 1,
    SpvKernelEnqueueFlagsWaitWorkGroup = 2,
    SpvKernelEnqueueFlagsMax = 0x7fffffff,
} SpvKernelEnqueueFlags;

typedef enum SpvKernelProfilingInfoShift_
{
    SpvKernelProfilingInfoCmdExecTimeShift = 0,
    SpvKernelProfilingInfoMax = 0x7fffffff,
} SpvKernelProfilingInfoShift;

typedef enum SpvKernelProfilingInfoMask_
{
    SpvKernelProfilingInfoMaskNone = 0,
    SpvKernelProfilingInfoCmdExecTimeMask = 0x00000001,
} SpvKernelProfilingInfoMask;

typedef enum SpvCapability_
{
    SpvCapabilityMatrix = 0,
    SpvCapabilityShader = 1,
    SpvCapabilityGeometry = 2,
    SpvCapabilityTessellation = 3,
    SpvCapabilityAddresses = 4,
    SpvCapabilityLinkage = 5,
    SpvCapabilityKernel = 6,
    SpvCapabilityVector16 = 7,
    SpvCapabilityFloat16Buffer = 8,
    SpvCapabilityFloat16 = 9,
    SpvCapabilityFloat64 = 10,
    SpvCapabilityInt64 = 11,
    SpvCapabilityInt64Atomics = 12,
    SpvCapabilityImageBasic = 13,
    SpvCapabilityImageReadWrite = 14,
    SpvCapabilityImageMipmap = 15,
    SpvCapabilityPipes = 17,
    SpvCapabilityGroups = 18,
    SpvCapabilityDeviceEnqueue = 19,
    SpvCapabilityLiteralSampler = 20,
    SpvCapabilityAtomicStorage = 21,
    SpvCapabilityInt16 = 22,
    SpvCapabilityTessellationPointSize = 23,
    SpvCapabilityGeometryPointSize = 24,
    SpvCapabilityImageGatherExtended = 25,
    SpvCapabilityStorageImageMultisample = 27,
    SpvCapabilityUniformBufferArrayDynamicIndexing = 28,
    SpvCapabilitySampledImageArrayDynamicIndexing = 29,
    SpvCapabilityStorageBufferArrayDynamicIndexing = 30,
    SpvCapabilityStorageImageArrayDynamicIndexing = 31,
    SpvCapabilityClipDistance = 32,
    SpvCapabilityCullDistance = 33,
    SpvCapabilityImageCubeArray = 34,
    SpvCapabilitySampleRateShading = 35,
    SpvCapabilityImageRect = 36,
    SpvCapabilitySampledRect = 37,
    SpvCapabilityGenericPointer = 38,
    SpvCapabilityInt8 = 39,
    SpvCapabilityInputAttachment = 40,
    SpvCapabilitySparseResidency = 41,
    SpvCapabilityMinLod = 42,
    SpvCapabilitySampled1D = 43,
    SpvCapabilityImage1D = 44,
    SpvCapabilitySampledCubeArray = 45,
    SpvCapabilitySampledBuffer = 46,
    SpvCapabilityImageBuffer = 47,
    SpvCapabilityImageMSArray = 48,
    SpvCapabilityStorageImageExtendedFormats = 49,
    SpvCapabilityImageQuery = 50,
    SpvCapabilityDerivativeControl = 51,
    SpvCapabilityInterpolationFunction = 52,
    SpvCapabilityTransformFeedback = 53,
    SpvCapabilityGeometryStreams = 54,
    SpvCapabilityStorageImageReadWithoutFormat = 55,
    SpvCapabilityStorageImageWriteWithoutFormat = 56,
    SpvCapabilityMultiViewport = 57,
    SpvCapabilitySubgroupDispatch = 58,
    SpvCapabilityNamedBarrier = 59,
    SpvCapabilityPipeStorage = 60,
    SpvCapabilityGroupNonUniform = 61,
    SpvCapabilityGroupNonUniformVote = 62,
    SpvCapabilityGroupNonUniformArithmetic = 63,
    SpvCapabilityGroupNonUniformBallot = 64,
    SpvCapabilityGroupNonUniformShuffle = 65,
    SpvCapabilityGroupNonUniformShuffleRelative = 66,
    SpvCapabilityGroupNonUniformClustered = 67,
    SpvCapabilityGroupNonUniformQuad = 68,
    SpvCapabilitySubgroupBallotKHR = 4423,
    SpvCapabilityDrawParameters = 4427,
    SpvCapabilitySubgroupVoteKHR = 4431,
    SpvCapabilityStorageBuffer16BitAccess = 4433,
    SpvCapabilityStorageUniformBufferBlock16 = 4433,
    SpvCapabilityStorageUniform16 = 4434,
    SpvCapabilityUniformAndStorageBuffer16BitAccess = 4434,
    SpvCapabilityStoragePushConstant16 = 4435,
    SpvCapabilityStorageInputOutput16 = 4436,
    SpvCapabilityDeviceGroup = 4437,
    SpvCapabilityMultiView = 4439,
    SpvCapabilityVariablePointersStorageBuffer = 4441,
    SpvCapabilityVariablePointers = 4442,
    SpvCapabilityAtomicStorageOps = 4445,
    SpvCapabilitySampleMaskPostDepthCoverage = 4447,
    SpvCapabilityFloat16ImageAMD = 5008,
    SpvCapabilityImageGatherBiasLodAMD = 5009,
    SpvCapabilityFragmentMaskAMD = 5010,
    SpvCapabilityStencilExportEXT = 5013,
    SpvCapabilityImageReadWriteLodAMD = 5015,
    SpvCapabilitySampleMaskOverrideCoverageNV = 5249,
    SpvCapabilityGeometryShaderPassthroughNV = 5251,
    SpvCapabilityShaderViewportIndexLayerEXT = 5254,
    SpvCapabilityShaderViewportIndexLayerNV = 5254,
    SpvCapabilityShaderViewportMaskNV = 5255,
    SpvCapabilityShaderStereoViewNV = 5259,
    SpvCapabilityPerViewAttributesNV = 5260,
    SpvCapabilityFragmentFullyCoveredEXT = 5265,
    SpvCapabilityGroupNonUniformPartitionedNV = 5297,
    SpvCapabilityRayTracingNV = 5340,
    SpvCapabilitySubgroupShuffleINTEL = 5568,
    SpvCapabilitySubgroupBufferBlockIOINTEL = 5569,
    SpvCapabilitySubgroupImageBlockIOINTEL = 5570,
    SpvCapabilityMax = 0x7fffffff,
} SpvCapability;

typedef enum SpvOp_
{
    SpvOpNop = 0,
    SpvOpUndef = 1,
    SpvOpSourceContinued = 2,
    SpvOpSource = 3,
    SpvOpSourceExtension = 4,
    SpvOpName = 5,
    SpvOpMemberName = 6,
    SpvOpString = 7,
    SpvOpLine = 8,
    SpvOpExtension = 10,
    SpvOpExtInstImport = 11,
    SpvOpExtInst = 12,
    SpvOpMemoryModel = 14,
    SpvOpEntryPoint = 15,
    SpvOpExecutionMode = 16,
    SpvOpCapability = 17,
    SpvOpTypeVoid = 19,
    SpvOpTypeBool = 20,
    SpvOpTypeInt = 21,
    SpvOpTypeFloat = 22,
    SpvOpTypeVector = 23,
    SpvOpTypeMatrix = 24,
    SpvOpTypeImage = 25,
    SpvOpTypeSampler = 26,
    SpvOpTypeSampledImage = 27,
    SpvOpTypeArray = 28,
    SpvOpTypeRuntimeArray = 29,
    SpvOpTypeStruct = 30,
    SpvOpTypeOpaque = 31,
    SpvOpTypePointer = 32,
    SpvOpTypeFunction = 33,
    SpvOpTypeEvent = 34,
    SpvOpTypeDeviceEvent = 35,
    SpvOpTypeReserveId = 36,
    SpvOpTypeQueue = 37,
    SpvOpTypePipe = 38,
    SpvOpTypeForwardPointer = 39,
    SpvOpConstantTrue = 41,
    SpvOpConstantFalse = 42,
    SpvOpConstant = 43,
    SpvOpConstantComposite = 44,
    SpvOpConstantSampler = 45,
    SpvOpConstantNull = 46,
    SpvOpSpecConstantTrue = 48,
    SpvOpSpecConstantFalse = 49,
    SpvOpSpecConstant = 50,
    SpvOpSpecConstantComposite = 51,
    SpvOpSpecConstantOp = 52,
    SpvOpFunction = 54,
    SpvOpFunctionParameter = 55,
    SpvOpFunctionEnd = 56,
    SpvOpFunctionCall = 57,
    SpvOpVariable = 59,
    SpvOpImageTexelPointer = 60,
    SpvOpLoad = 61,
    SpvOpStore = 62,
    SpvOpCopyMemory = 63,
    SpvOpCopyMemorySized = 64,
    SpvOpAccessChain = 65,
    SpvOpInBoundsAccessChain = 66,
    SpvOpPtrAccessChain = 67,
    SpvOpArrayLength = 68,
    SpvOpGenericPtrMemSemantics = 69,
    SpvOpInBoundsPtrAccessChain = 70,
    SpvOpDecorate = 71,
    SpvOpMemberDecorate = 72,
    SpvOpDecorationGroup = 73,
    SpvOpGroupDecorate = 74,
    SpvOpGroupMemberDecorate = 75,
    SpvOpVectorExtractDynamic = 77,
    SpvOpVectorInsertDynamic = 78,
    SpvOpVectorShuffle = 79,
    SpvOpCompositeConstruct = 80,
    SpvOpCompositeExtract = 81,
    SpvOpCompositeInsert = 82,
    SpvOpCopyObject = 83,
    SpvOpTranspose = 84,
    SpvOpSampledImage = 86,
    SpvOpImageSampleImplicitLod = 87,
    SpvOpImageSampleExplicitLod = 88,
    SpvOpImageSampleDrefImplicitLod = 89,
    SpvOpImageSampleDrefExplicitLod = 90,
    SpvOpImageSampleProjImplicitLod = 91,
    SpvOpImageSampleProjExplicitLod = 92,
    SpvOpImageSampleProjDrefImplicitLod = 93,
    SpvOpImageSampleProjDrefExplicitLod = 94,
    SpvOpImageFetch = 95,
    SpvOpImageGather = 96,
    SpvOpImageDrefGather = 97,
    SpvOpImageRead = 98,
    SpvOpImageWrite = 99,
    SpvOpImage = 100,
    SpvOpImageQueryFormat = 101,
    SpvOpImageQueryOrder = 102,
    SpvOpImageQuerySizeLod = 103,
    SpvOpImageQuerySize = 104,
    SpvOpImageQueryLod = 105,
    SpvOpImageQueryLevels = 106,
    SpvOpImageQuerySamples = 107,
    SpvOpConvertFToU = 109,
    SpvOpConvertFToS = 110,
    SpvOpConvertSToF = 111,
    SpvOpConvertUToF = 112,
    SpvOpUConvert = 113,
    SpvOpSConvert = 114,
    SpvOpFConvert = 115,
    SpvOpQuantizeToF16 = 116,
    SpvOpConvertPtrToU = 117,
    SpvOpSatConvertSToU = 118,
    SpvOpSatConvertUToS = 119,
    SpvOpConvertUToPtr = 120,
    SpvOpPtrCastToGeneric = 121,
    SpvOpGenericCastToPtr = 122,
    SpvOpGenericCastToPtrExplicit = 123,
    SpvOpBitcast = 124,
    SpvOpSNegate = 126,
    SpvOpFNegate = 127,
    SpvOpIAdd = 128,
    SpvOpFAdd = 129,
    SpvOpISub = 130,
    SpvOpFSub = 131,
    SpvOpIMul = 132,
    SpvOpFMul = 133,
    SpvOpUDiv = 134,
    SpvOpSDiv = 135,
    SpvOpFDiv = 136,
    SpvOpUMod = 137,
    SpvOpSRem = 138,
    SpvOpSMod = 139,
    SpvOpFRem = 140,
    SpvOpFMod = 141,
    SpvOpVectorTimesScalar = 142,
    SpvOpMatrixTimesScalar = 143,
    SpvOpVectorTimesMatrix = 144,
    SpvOpMatrixTimesVector = 145,
    SpvOpMatrixTimesMatrix = 146,
    SpvOpOuterProduct = 147,
    SpvOpDot = 148,
    SpvOpIAddCarry = 149,
    SpvOpISubBorrow = 150,
    SpvOpUMulExtended = 151,
    SpvOpSMulExtended = 152,
    SpvOpAny = 154,
    SpvOpAll = 155,
    SpvOpIsNan = 156,
    SpvOpIsInf = 157,
    SpvOpIsFinite = 158,
    SpvOpIsNormal = 159,
    SpvOpSignBitSet = 160,
    SpvOpLessOrGreater = 161,
    SpvOpOrdered = 162,
    SpvOpUnordered = 163,
    SpvOpLogicalEqual = 164,
    SpvOpLogicalNotEqual = 165,
    SpvOpLogicalOr = 166,
    SpvOpLogicalAnd = 167,
    SpvOpLogicalNot = 168,
    SpvOpSelect = 169,
    SpvOpIEqual = 170,
    SpvOpINotEqual = 171,
    SpvOpUGreaterThan = 172,
    SpvOpSGreaterThan = 173,
    SpvOpUGreaterThanEqual = 174,
    SpvOpSGreaterThanEqual = 175,
    SpvOpULessThan = 176,
    SpvOpSLessThan = 177,
    SpvOpULessThanEqual = 178,
    SpvOpSLessThanEqual = 179,
    SpvOpFOrdEqual = 180,
    SpvOpFUnordEqual = 181,
    SpvOpFOrdNotEqual = 182,
    SpvOpFUnordNotEqual = 183,
    SpvOpFOrdLessThan = 184,
    SpvOpFUnordLessThan = 185,
    SpvOpFOrdGreaterThan = 186,
    SpvOpFUnordGreaterThan = 187,
    SpvOpFOrdLessThanEqual = 188,
    SpvOpFUnordLessThanEqual = 189,
    SpvOpFOrdGreaterThanEqual = 190,
    SpvOpFUnordGreaterThanEqual = 191,
    SpvOpShiftRightLogical = 194,
    SpvOpShiftRightArithmetic = 195,
    SpvOpShiftLeftLogical = 196,
    SpvOpBitwiseOr = 197,
    SpvOpBitwiseXor = 198,
    SpvOpBitwiseAnd = 199,
    SpvOpNot = 200,
    SpvOpBitFieldInsert = 201,
    SpvOpBitFieldSExtract = 202,
    SpvOpBitFieldUExtract = 203,
    SpvOpBitReverse = 204,
    SpvOpBitCount = 205,
    SpvOpDPdx = 207,
    SpvOpDPdy = 208,
    SpvOpFwidth = 209,
    SpvOpDPdxFine = 210,
    SpvOpDPdyFine = 211,
    SpvOpFwidthFine = 212,
    SpvOpDPdxCoarse = 213,
    SpvOpDPdyCoarse = 214,
    SpvOpFwidthCoarse = 215,
    SpvOpEmitVertex = 218,
    SpvOpEndPrimitive = 219,
    SpvOpEmitStreamVertex = 220,
    SpvOpEndStreamPrimitive = 221,
    SpvOpControlBarrier = 224,
    SpvOpMemoryBarrier = 225,
    SpvOpAtomicLoad = 227,
    SpvOpAtomicStore = 228,
    SpvOpAtomicExchange = 229,
    SpvOpAtomicCompareExchange = 230,
    SpvOpAtomicCompareExchangeWeak = 231,
    SpvOpAtomicIIncrement = 232,
    SpvOpAtomicIDecrement = 233,
    SpvOpAtomicIAdd = 234,
    SpvOpAtomicISub = 235,
    SpvOpAtomicSMin = 236,
    SpvOpAtomicUMin = 237,
    SpvOpAtomicSMax = 238,
    SpvOpAtomicUMax = 239,
    SpvOpAtomicAnd = 240,
    SpvOpAtomicOr = 241,
    SpvOpAtomicXor = 242,
    SpvOpPhi = 245,
    SpvOpLoopMerge = 246,
    SpvOpSelectionMerge = 247,
    SpvOpLabel = 248,
    SpvOpBranch = 249,
    SpvOpBranchConditional = 250,
    SpvOpSwitch = 251,
    SpvOpKill = 252,
    SpvOpReturn = 253,
    SpvOpReturnValue = 254,
    SpvOpUnreachable = 255,
    SpvOpLifetimeStart = 256,
    SpvOpLifetimeStop = 257,
    SpvOpGroupAsyncCopy = 259,
    SpvOpGroupWaitEvents = 260,
    SpvOpGroupAll = 261,
    SpvOpGroupAny = 262,
    SpvOpGroupBroadcast = 263,
    SpvOpGroupIAdd = 264,
    SpvOpGroupFAdd = 265,
    SpvOpGroupFMin = 266,
    SpvOpGroupUMin = 267,
    SpvOpGroupSMin = 268,
    SpvOpGroupFMax = 269,
    SpvOpGroupUMax = 270,
    SpvOpGroupSMax = 271,
    SpvOpReadPipe = 274,
    SpvOpWritePipe = 275,
    SpvOpReservedReadPipe = 276,
    SpvOpReservedWritePipe = 277,
    SpvOpReserveReadPipePackets = 278,
    SpvOpReserveWritePipePackets = 279,
    SpvOpCommitReadPipe = 280,
    SpvOpCommitWritePipe = 281,
    SpvOpIsValidReserveId = 282,
    SpvOpGetNumPipePackets = 283,
    SpvOpGetMaxPipePackets = 284,
    SpvOpGroupReserveReadPipePackets = 285,
    SpvOpGroupReserveWritePipePackets = 286,
    SpvOpGroupCommitReadPipe = 287,
    SpvOpGroupCommitWritePipe = 288,
    SpvOpEnqueueMarker = 291,
    SpvOpEnqueueKernel = 292,
    SpvOpGetKernelNDrangeSubGroupCount = 293,
    SpvOpGetKernelNDrangeMaxSubGroupSize = 294,
    SpvOpGetKernelWorkGroupSize = 295,
    SpvOpGetKernelPreferredWorkGroupSizeMultiple = 296,
    SpvOpRetainEvent = 297,
    SpvOpReleaseEvent = 298,
    SpvOpCreateUserEvent = 299,
    SpvOpIsValidEvent = 300,
    SpvOpSetUserEventStatus = 301,
    SpvOpCaptureEventProfilingInfo = 302,
    SpvOpGetDefaultQueue = 303,
    SpvOpBuildNDRange = 304,
    SpvOpImageSparseSampleImplicitLod = 305,
    SpvOpImageSparseSampleExplicitLod = 306,
    SpvOpImageSparseSampleDrefImplicitLod = 307,
    SpvOpImageSparseSampleDrefExplicitLod = 308,
    SpvOpImageSparseSampleProjImplicitLod = 309,
    SpvOpImageSparseSampleProjExplicitLod = 310,
    SpvOpImageSparseSampleProjDrefImplicitLod = 311,
    SpvOpImageSparseSampleProjDrefExplicitLod = 312,
    SpvOpImageSparseFetch = 313,
    SpvOpImageSparseGather = 314,
    SpvOpImageSparseDrefGather = 315,
    SpvOpImageSparseTexelsResident = 316,
    SpvOpNoLine = 317,
    SpvOpAtomicFlagTestAndSet = 318,
    SpvOpAtomicFlagClear = 319,
    SpvOpImageSparseRead = 320,
    SpvOpSizeOf = 321,
    SpvOpTypePipeStorage = 322,
    SpvOpConstantPipeStorage = 323,
    SpvOpCreatePipeFromPipeStorage = 324,
    SpvOpGetKernelLocalSizeForSubgroupCount = 325,
    SpvOpGetKernelMaxNumSubgroups = 326,
    SpvOpTypeNamedBarrier = 327,
    SpvOpNamedBarrierInitialize = 328,
    SpvOpMemoryNamedBarrier = 329,
    SpvOpModuleProcessed = 330,
    SpvOpExecutionModeId = 331,
    SpvOpDecorateId = 332,
    SpvOpGroupNonUniformElect = 333,
    SpvOpGroupNonUniformAll = 334,
    SpvOpGroupNonUniformAny = 335,
    SpvOpGroupNonUniformAllEqual = 336,
    SpvOpGroupNonUniformBroadcast = 337,
    SpvOpGroupNonUniformBroadcastFirst = 338,
    SpvOpGroupNonUniformBallot = 339,
    SpvOpGroupNonUniformInverseBallot = 340,
    SpvOpGroupNonUniformBallotBitExtract = 341,
    SpvOpGroupNonUniformBallotBitCount = 342,
    SpvOpGroupNonUniformBallotFindLSB = 343,
    SpvOpGroupNonUniformBallotFindMSB = 344,
    SpvOpGroupNonUniformShuffle = 345,
    SpvOpGroupNonUniformShuffleXor = 346,
    SpvOpGroupNonUniformShuffleUp = 347,
    SpvOpGroupNonUniformShuffleDown = 348,
    SpvOpGroupNonUniformIAdd = 349,
    SpvOpGroupNonUniformFAdd = 350,
    SpvOpGroupNonUniformIMul = 351,
    SpvOpGroupNonUniformFMul = 352,
    SpvOpGroupNonUniformSMin = 353,
    SpvOpGroupNonUniformUMin = 354,
    SpvOpGroupNonUniformFMin = 355,
    SpvOpGroupNonUniformSMax = 356,
    SpvOpGroupNonUniformUMax = 357,
    SpvOpGroupNonUniformFMax = 358,
    SpvOpGroupNonUniformBitwiseAnd = 359,
    SpvOpGroupNonUniformBitwiseOr = 360,
    SpvOpGroupNonUniformBitwiseXor = 361,
    SpvOpGroupNonUniformLogicalAnd = 362,
    SpvOpGroupNonUniformLogicalOr = 363,
    SpvOpGroupNonUniformLogicalXor = 364,
    SpvOpGroupNonUniformQuadBroadcast = 365,
    SpvOpGroupNonUniformQuadSwap = 366,
    SpvOpSubgroupBallotKHR = 4421,
    SpvOpSubgroupFirstInvocationKHR = 4422,
    SpvOpSubgroupAllKHR = 4428,
    SpvOpSubgroupAnyKHR = 4429,
    SpvOpSubgroupAllEqualKHR = 4430,
    SpvOpSubgroupReadInvocationKHR = 4432,
    SpvOpGroupIAddNonUniformAMD = 5000,
    SpvOpGroupFAddNonUniformAMD = 5001,
    SpvOpGroupFMinNonUniformAMD = 5002,
    SpvOpGroupUMinNonUniformAMD = 5003,
    SpvOpGroupSMinNonUniformAMD = 5004,
    SpvOpGroupFMaxNonUniformAMD = 5005,
    SpvOpGroupUMaxNonUniformAMD = 5006,
    SpvOpGroupSMaxNonUniformAMD = 5007,
    SpvOpFragmentMaskFetchAMD = 5011,
    SpvOpFragmentFetchAMD = 5012,
    SpvOpGroupNonUniformPartitionNV = 5296,
    // SPV_NV_ray_tracing
    SpvOpReportIntersectionNV = 5334,
    SpvOpIgnoreIntersectionNV = 5335,
    SpvOpTerminateRayNV = 5336,
    SpvOpTraceNV = 5337,
    SpvOpTypeAccelerationStructureNV = 5341,
    SpvOpExecuteCallableNV = 5344,
    // end of SPV_NV_ray_tracing
    SpvOpSubgroupShuffleINTEL = 5571,
    SpvOpSubgroupShuffleDownINTEL = 5572,
    SpvOpSubgroupShuffleUpINTEL = 5573,
    SpvOpSubgroupShuffleXorINTEL = 5574,
    SpvOpSubgroupBlockReadINTEL = 5575,
    SpvOpSubgroupBlockWriteINTEL = 5576,
    SpvOpSubgroupImageBlockReadINTEL = 5577,
    SpvOpSubgroupImageBlockWriteINTEL = 5578,
    SpvOpDecorateStringGOOGLE = 5632,
    SpvOpMemberDecorateStringGOOGLE = 5633,
    SpvOpMax = 0x7fffffff,
} SpvOp;

#endif // #ifndef spirv_H


#include <stdint.h>
#include <string.h>

#ifdef _MSC_VER
#define SPV_REFLECT_DEPRECATED(msg_str) __declspec(deprecated("This symbol is deprecated. Details: " msg_str))
#elif defined(__clang__)
#define SPV_REFLECT_DEPRECATED(msg_str) __attribute__((deprecated(msg_str)))
#elif defined(__GNUC__)
#if GCC_VERSION >= 40500
#define SPV_REFLECT_DEPRECATED(msg_str) __attribute__((deprecated(msg_str)))
#else
#define SPV_REFLECT_DEPRECATED(msg_str) __attribute__((deprecated))
#endif
#else
#define SPV_REFLECT_DEPRECATED(msg_str)
#endif

/*! @enum SpvReflectResult

*/
typedef enum SpvReflectResult
{
    SPV_REFLECT_RESULT_SUCCESS,
    SPV_REFLECT_RESULT_NOT_READY,
    SPV_REFLECT_RESULT_ERROR_PARSE_FAILED,
    SPV_REFLECT_RESULT_ERROR_ALLOC_FAILED,
    SPV_REFLECT_RESULT_ERROR_RANGE_EXCEEDED,
    SPV_REFLECT_RESULT_ERROR_NULL_POINTER,
    SPV_REFLECT_RESULT_ERROR_INTERNAL_ERROR,
    SPV_REFLECT_RESULT_ERROR_COUNT_MISMATCH,
    SPV_REFLECT_RESULT_ERROR_ELEMENT_NOT_FOUND,
    SPV_REFLECT_RESULT_ERROR_SPIRV_INVALID_CODE_SIZE,
    SPV_REFLECT_RESULT_ERROR_SPIRV_INVALID_MAGIC_NUMBER,
    SPV_REFLECT_RESULT_ERROR_SPIRV_UNEXPECTED_EOF,
    SPV_REFLECT_RESULT_ERROR_SPIRV_INVALID_ID_REFERENCE,
    SPV_REFLECT_RESULT_ERROR_SPIRV_SET_NUMBER_OVERFLOW,
    SPV_REFLECT_RESULT_ERROR_SPIRV_INVALID_STORAGE_CLASS,
    SPV_REFLECT_RESULT_ERROR_SPIRV_RECURSION,
    SPV_REFLECT_RESULT_ERROR_SPIRV_INVALID_INSTRUCTION,
    SPV_REFLECT_RESULT_ERROR_SPIRV_UNEXPECTED_BLOCK_DATA,
    SPV_REFLECT_RESULT_ERROR_SPIRV_INVALID_BLOCK_MEMBER_REFERENCE,
    SPV_REFLECT_RESULT_ERROR_SPIRV_INVALID_ENTRY_POINT,
    SPV_REFLECT_RESULT_ERROR_SPIRV_INVALID_EXECUTION_MODE,
} SpvReflectResult;

/*! @enum SpvReflectTypeFlagBits

*/
typedef enum SpvReflectTypeFlagBits
{
    SPV_REFLECT_TYPE_FLAG_UNDEFINED = 0x00000000,
    SPV_REFLECT_TYPE_FLAG_VOID = 0x00000001,
    SPV_REFLECT_TYPE_FLAG_BOOL = 0x00000002,
    SPV_REFLECT_TYPE_FLAG_INT = 0x00000004,
    SPV_REFLECT_TYPE_FLAG_FLOAT = 0x00000008,
    SPV_REFLECT_TYPE_FLAG_VECTOR = 0x00000100,
    SPV_REFLECT_TYPE_FLAG_MATRIX = 0x00000200,
    SPV_REFLECT_TYPE_FLAG_EXTERNAL_IMAGE = 0x00010000,
    SPV_REFLECT_TYPE_FLAG_EXTERNAL_SAMPLER = 0x00020000,
    SPV_REFLECT_TYPE_FLAG_EXTERNAL_SAMPLED_IMAGE = 0x00040000,
    SPV_REFLECT_TYPE_FLAG_EXTERNAL_BLOCK = 0x00080000,
    SPV_REFLECT_TYPE_FLAG_EXTERNAL_OPAQUE = 0x00100000,
    SPV_REFLECT_TYPE_FLAG_EXTERNAL_MASK = 0x001F0000,
    SPV_REFLECT_TYPE_FLAG_STRUCT = 0x10000000,
    SPV_REFLECT_TYPE_FLAG_ARRAY = 0x20000000,
} SpvReflectTypeFlagBits;

typedef uint32_t SpvReflectTypeFlags;

/*! @enum SpvReflectDecorationBits

*/
typedef enum SpvReflectDecorationFlagBits
{
    SPV_REFLECT_DECORATION_NONE = 0x00000000,
    SPV_REFLECT_DECORATION_BLOCK = 0x00000001,
    SPV_REFLECT_DECORATION_BUFFER_BLOCK = 0x00000002,
    SPV_REFLECT_DECORATION_ROW_MAJOR = 0x00000004,
    SPV_REFLECT_DECORATION_COLUMN_MAJOR = 0x00000008,
    SPV_REFLECT_DECORATION_BUILT_IN = 0x00000010,
    SPV_REFLECT_DECORATION_NOPERSPECTIVE = 0x00000020,
    SPV_REFLECT_DECORATION_FLAT = 0x00000040,
    SPV_REFLECT_DECORATION_NON_WRITABLE = 0x00000080,
} SpvReflectDecorationFlagBits;

typedef uint32_t SpvReflectDecorationFlags;

/*! @enum SpvReflectResourceType

*/
typedef enum SpvReflectResourceType
{
    SPV_REFLECT_RESOURCE_FLAG_UNDEFINED = 0x00000000,
    SPV_REFLECT_RESOURCE_FLAG_SAMPLER = 0x00000001,
    SPV_REFLECT_RESOURCE_FLAG_CBV = 0x00000002,
    SPV_REFLECT_RESOURCE_FLAG_SRV = 0x00000004,
    SPV_REFLECT_RESOURCE_FLAG_UAV = 0x00000008,
} SpvReflectResourceType;

/*! @enum SpvReflectFormat

*/
typedef enum SpvReflectFormat
{
    SPV_REFLECT_FORMAT_UNDEFINED = 0,             // = VK_FORMAT_UNDEFINED
    SPV_REFLECT_FORMAT_R32_UINT = 98,             // = VK_FORMAT_R32_UINT
    SPV_REFLECT_FORMAT_R32_SINT = 99,             // = VK_FORMAT_R32_SINT
    SPV_REFLECT_FORMAT_R32_SFLOAT = 100,          // = VK_FORMAT_R32_SFLOAT
    SPV_REFLECT_FORMAT_R32G32_UINT = 101,         // = VK_FORMAT_R32G32_UINT
    SPV_REFLECT_FORMAT_R32G32_SINT = 102,         // = VK_FORMAT_R32G32_SINT
    SPV_REFLECT_FORMAT_R32G32_SFLOAT = 103,       // = VK_FORMAT_R32G32_SFLOAT
    SPV_REFLECT_FORMAT_R32G32B32_UINT = 104,      // = VK_FORMAT_R32G32B32_UINT
    SPV_REFLECT_FORMAT_R32G32B32_SINT = 105,      // = VK_FORMAT_R32G32B32_SINT
    SPV_REFLECT_FORMAT_R32G32B32_SFLOAT = 106,    // = VK_FORMAT_R32G32B32_SFLOAT
    SPV_REFLECT_FORMAT_R32G32B32A32_UINT = 107,   // = VK_FORMAT_R32G32B32A32_UINT
    SPV_REFLECT_FORMAT_R32G32B32A32_SINT = 108,   // = VK_FORMAT_R32G32B32A32_SINT
    SPV_REFLECT_FORMAT_R32G32B32A32_SFLOAT = 109, // = VK_FORMAT_R32G32B32A32_SFLOAT
} SpvReflectFormat;

/*! @enum SpvReflectVariableFlagBits

*/
enum SpvReflectVariableFlagBits
{
    SPV_REFLECT_VARIABLE_FLAGS_NONE = 0x00000000,
    SPV_REFLECT_VARIABLE_FLAGS_UNUSED = 0x00000001,
};

typedef uint32_t SpvReflectVariableFlags;

/*! @enum SpvReflectDescriptorType

*/
typedef enum SpvReflectDescriptorType
{
    SPV_REFLECT_DESCRIPTOR_TYPE_SAMPLER = 0,                            // = VK_DESCRIPTOR_TYPE_SAMPLER
    SPV_REFLECT_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,             // = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
    SPV_REFLECT_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,                      // = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE
    SPV_REFLECT_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,                      // = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE
    SPV_REFLECT_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,               // = VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER
    SPV_REFLECT_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,               // = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER
    SPV_REFLECT_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,                     // = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER
    SPV_REFLECT_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,                     // = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER
    SPV_REFLECT_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,             // = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC
    SPV_REFLECT_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,             // = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC
    SPV_REFLECT_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,                  // = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT
    SPV_REFLECT_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000, // = VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV
} SpvReflectDescriptorType;

/*! @enum SpvReflectShaderStageFlagBits

*/
typedef enum SpvReflectShaderStageFlagBits
{
    SPV_REFLECT_SHADER_STAGE_VERTEX_BIT = 0x00000001,                  // = VK_SHADER_STAGE_VERTEX_BIT
    SPV_REFLECT_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002,    // = VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT
    SPV_REFLECT_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004, // = VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
    SPV_REFLECT_SHADER_STAGE_GEOMETRY_BIT = 0x00000008,                // = VK_SHADER_STAGE_GEOMETRY_BIT
    SPV_REFLECT_SHADER_STAGE_FRAGMENT_BIT = 0x00000010,                // = VK_SHADER_STAGE_FRAGMENT_BIT
    SPV_REFLECT_SHADER_STAGE_COMPUTE_BIT = 0x00000020,                 // = VK_SHADER_STAGE_COMPUTE_BIT
    SPV_REFLECT_SHADER_STAGE_RAYGEN_BIT_NV = 0x00000100,               // = VK_SHADER_STAGE_RAYGEN_BIT_NV
    SPV_REFLECT_SHADER_STAGE_ANY_HIT_BIT_NV = 0x00000200,              // = VK_SHADER_STAGE_ANY_HIT_BIT_NV
    SPV_REFLECT_SHADER_STAGE_CLOSEST_HIT_BIT_NV = 0x00000400,          // = VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV
    SPV_REFLECT_SHADER_STAGE_MISS_BIT_NV = 0x00000800,                 // = VK_SHADER_STAGE_MISS_BIT_NV
    SPV_REFLECT_SHADER_STAGE_INTERSECTION_BIT_NV = 0x00001000,         // = VK_SHADER_STAGE_INTERSECTION_BIT_NV
    SPV_REFLECT_SHADER_STAGE_CALLABLE_BIT_NV = 0x00002000,             // = VK_SHADER_STAGE_CALLABLE_BIT_NV
} SpvReflectShaderStageFlagBits;

/*! @enum SpvReflectGenerator

*/
typedef enum SpvReflectGenerator
{
    SPV_REFLECT_GENERATOR_KHRONOS_LLVM_SPIRV_TRANSLATOR = 6,
    SPV_REFLECT_GENERATOR_KHRONOS_SPIRV_TOOLS_ASSEMBLER = 7,
    SPV_REFLECT_GENERATOR_KHRONOS_GLSLANG_REFERENCE_FRONT_END = 8,
    SPV_REFLECT_GENERATOR_GOOGLE_SHADERC_OVER_GLSLANG = 13,
    SPV_REFLECT_GENERATOR_GOOGLE_SPIREGG = 14,
    SPV_REFLECT_GENERATOR_GOOGLE_RSPIRV = 15,
    SPV_REFLECT_GENERATOR_X_LEGEND_MESA_MESAIR_SPIRV_TRANSLATOR = 16,
    SPV_REFLECT_GENERATOR_KHRONOS_SPIRV_TOOLS_LINKER = 17,
    SPV_REFLECT_GENERATOR_WINE_VKD3D_SHADER_COMPILER = 18,
    SPV_REFLECT_GENERATOR_CLAY_CLAY_SHADER_COMPILER = 19,
} SpvReflectGenerator;

enum
{
    SPV_REFLECT_MAX_ARRAY_DIMS = 32,
    SPV_REFLECT_MAX_DESCRIPTOR_SETS = 64,
};

enum
{
    SPV_REFLECT_BINDING_NUMBER_DONT_CHANGE = ~0,
    SPV_REFLECT_SET_NUMBER_DONT_CHANGE = ~0
};

typedef struct SpvReflectNumericTraits
{
    struct Scalar
    {
        uint32_t width;
        uint32_t signedness;
    } scalar;

    struct Vector
    {
        uint32_t component_count;
    } vector;

    struct Matrix
    {
        uint32_t column_count;
        uint32_t row_count;
        uint32_t stride; // Measured in bytes
    } matrix;
} SpvReflectNumericTraits;

typedef struct SpvReflectImageTraits
{
    SpvDim dim;
    uint32_t depth;
    uint32_t arrayed;
    uint32_t ms; // 0: single-sampled; 1: multisampled
    uint32_t sampled;
    SpvImageFormat image_format;
} SpvReflectImageTraits;

typedef struct SpvReflectArrayTraits
{
    uint32_t dims_count;
    uint32_t dims[SPV_REFLECT_MAX_ARRAY_DIMS];
    uint32_t stride; // Measured in bytes
} SpvReflectArrayTraits;

typedef struct SpvReflectBindingArrayTraits
{
    uint32_t dims_count;
    uint32_t dims[SPV_REFLECT_MAX_ARRAY_DIMS];
} SpvReflectBindingArrayTraits;

/*! @struct SpvReflectTypeDescription

*/
typedef struct SpvReflectTypeDescription
{
    uint32_t id;
    SpvOp op;
    const char* type_name;
    const char* struct_member_name;
    SpvStorageClass storage_class;
    SpvReflectTypeFlags type_flags;
    SpvReflectDecorationFlags decoration_flags;

    struct Traits
    {
        SpvReflectNumericTraits numeric;
        SpvReflectImageTraits image;
        SpvReflectArrayTraits array;
    } traits;

    uint32_t member_count;
    struct SpvReflectTypeDescription* members;
} SpvReflectTypeDescription;


/*! @struct SpvReflectInterfaceVariable

*/
typedef struct SpvReflectInterfaceVariable
{
    uint32_t spirv_id;
    const char* name;
    uint32_t location;
    SpvStorageClass storage_class;
    const char* semantic;
    SpvReflectDecorationFlags decoration_flags;
    SpvBuiltIn built_in;
    SpvReflectNumericTraits numeric;
    SpvReflectArrayTraits array;

    uint32_t member_count;
    struct SpvReflectInterfaceVariable* members;

    SpvReflectFormat format;

    // NOTE: SPIR-V shares type references for variables
    //       that have the same underlying type. This means
    //       that the same type name will appear for multiple
    //       variables.
    SpvReflectTypeDescription* type_description;

    struct
    {
        uint32_t location;
    } word_offset;
} SpvReflectInterfaceVariable;

/*! @struct SpvReflectBlockVariable

*/
typedef struct SpvReflectBlockVariable
{
    uint32_t spirv_id;
    const char* name;
    uint32_t offset;          // Measured in bytes
    uint32_t absolute_offset; // Measured in bytes
    uint32_t size;            // Measured in bytes
    uint32_t padded_size;     // Measured in bytes
    SpvReflectDecorationFlags decoration_flags;
    SpvReflectNumericTraits numeric;
    SpvReflectArrayTraits array;
    SpvReflectVariableFlags flags;

    uint32_t member_count;
    struct SpvReflectBlockVariable* members;

    SpvReflectTypeDescription* type_description;
} SpvReflectBlockVariable;

/*! @struct SpvReflectDescriptorBinding

*/
typedef struct SpvReflectDescriptorBinding
{
    uint32_t spirv_id;
    const char* name;
    uint32_t binding;
    uint32_t input_attachment_index;
    uint32_t set;
    SpvReflectDescriptorType descriptor_type;
    SpvReflectResourceType resource_type;
    SpvReflectImageTraits image;
    SpvReflectBlockVariable block;
    SpvReflectBindingArrayTraits array;
    uint32_t count;
    uint32_t accessed;
    uint32_t uav_counter_id;
    struct SpvReflectDescriptorBinding* uav_counter_binding;

    SpvReflectTypeDescription* type_description;

    struct
    {
        uint32_t binding;
        uint32_t set;
    } word_offset;
} SpvReflectDescriptorBinding;

/*! @struct SpvReflectDescriptorSet

*/
typedef struct SpvReflectDescriptorSet
{
    uint32_t set;
    uint32_t binding_count;
    SpvReflectDescriptorBinding** bindings;
} SpvReflectDescriptorSet;

/*! @struct SpvReflectEntryPoint

 */
typedef struct SpvReflectEntryPoint
{
    const char* name;
    uint32_t id;

    SpvExecutionModel spirv_execution_model;
    SpvReflectShaderStageFlagBits shader_stage;

    uint32_t input_variable_count;
    SpvReflectInterfaceVariable* input_variables;
    uint32_t output_variable_count;
    SpvReflectInterfaceVariable* output_variables;

    uint32_t descriptor_set_count;
    SpvReflectDescriptorSet* descriptor_sets;

    uint32_t used_uniform_count;
    uint32_t* used_uniforms;
    uint32_t used_push_constant_count;
    uint32_t* used_push_constants;

    struct LocalSize
    {
        uint32_t x;
        uint32_t y;
        uint32_t z;
    } local_size;
} SpvReflectEntryPoint;

/*! @struct SpvReflectShaderModule

*/
typedef struct SpvReflectShaderModule
{
    SpvReflectGenerator generator;
    const char* entry_point_name;
    uint32_t entry_point_id;
    uint32_t entry_point_count;
    SpvReflectEntryPoint* entry_points;
    SpvSourceLanguage source_language;
    uint32_t source_language_version;
    const char* source_file;
    const char* source_source;
    SpvExecutionModel spirv_execution_model;
    SpvReflectShaderStageFlagBits shader_stage;
    uint32_t descriptor_binding_count;
    SpvReflectDescriptorBinding* descriptor_bindings;
    uint32_t descriptor_set_count;
    SpvReflectDescriptorSet descriptor_sets[SPV_REFLECT_MAX_DESCRIPTOR_SETS];
    uint32_t input_variable_count;
    SpvReflectInterfaceVariable* input_variables;
    uint32_t output_variable_count;
    SpvReflectInterfaceVariable* output_variables;
    uint32_t push_constant_block_count;
    SpvReflectBlockVariable* push_constant_blocks;

    struct Internal
    {
        size_t spirv_size;
        uint32_t* spirv_code;
        uint32_t spirv_word_count;

        size_t type_description_count;
        SpvReflectTypeDescription* type_descriptions;
    } * _internal;

} SpvReflectShaderModule;

#if defined(__cplusplus)
extern "C"
{
#endif

    /*! @fn spvReflectCreateShaderModule

     @param  size      Size in bytes of SPIR-V code.
     @param  p_code    Pointer to SPIR-V code.
     @param  p_module  Pointer to an instance of SpvReflectShaderModule.
     @return           SPV_REFLECT_RESULT_SUCCESS on success.

    */
    SpvReflectResult spvReflectCreateShaderModule(size_t size, const void* p_code, SpvReflectShaderModule* p_module);

    SPV_REFLECT_DEPRECATED("renamed to spvReflectCreateShaderModule")
    SpvReflectResult spvReflectGetShaderModule(size_t size, const void* p_code, SpvReflectShaderModule* p_module);


    /*! @fn spvReflectDestroyShaderModule

     @param  p_module  Pointer to an instance of SpvReflectShaderModule.

    */
    void spvReflectDestroyShaderModule(SpvReflectShaderModule* p_module);


    /*! @fn spvReflectGetCodeSize

     @param  p_module  Pointer to an instance of SpvReflectShaderModule.
     @return           Returns the size of the SPIR-V in bytes

    */
    uint32_t spvReflectGetCodeSize(const SpvReflectShaderModule* p_module);


    /*! @fn spvReflectGetCode

     @param  p_module  Pointer to an instance of SpvReflectShaderModule.
     @return           Returns a const pointer to the compiled SPIR-V bytecode.

    */
    const uint32_t* spvReflectGetCode(const SpvReflectShaderModule* p_module);

    /*! @fn spvReflectGetEntryPoint

     @param  p_module     Pointer to an instance of SpvReflectShaderModule.
     @param  entry_point  Name of the requested entry point.
     @return              Returns a const pointer to the requested entry point,
                          or NULL if it's not found.
    */
    const SpvReflectEntryPoint* spvReflectGetEntryPoint(const SpvReflectShaderModule* p_module, const char* entry_point);

    /*! @fn spvReflectEnumerateDescriptorBindings

     @param  p_module     Pointer to an instance of SpvReflectShaderModule.
     @param  p_count      If pp_bindings is NULL, the module's descriptor binding
                          count (across all descriptor sets) will be stored here.
                          If pp_bindings is not NULL, *p_count must contain the
                          module's descriptor binding count.
     @param  pp_bindings  If NULL, the module's total descriptor binding count
                          will be written to *p_count.
                          If non-NULL, pp_bindings must point to an array with
                          *p_count entries, where pointers to the module's
                          descriptor bindings will be written. The caller must not
                          free the binding pointers written to this array.
     @return              If successful, returns SPV_REFLECT_RESULT_SUCCESS.
                          Otherwise, the error code indicates the cause of the
                          failure.

    */
    SpvReflectResult spvReflectEnumerateDescriptorBindings(const SpvReflectShaderModule* p_module, uint32_t* p_count, SpvReflectDescriptorBinding** pp_bindings);

    /*! @fn spvReflectEnumerateEntryPointDescriptorBindings
     @brief  Creates a listing of all descriptor bindings that are used in the
             static call tree of the given entry point.
     @param  p_module     Pointer to an instance of SpvReflectShaderModule.
     @param  entry_point  The name of the entry point to get the descriptor bindings for.
     @param  p_count      If pp_bindings is NULL, the entry point's descriptor binding
                          count (across all descriptor sets) will be stored here.
                          If pp_bindings is not NULL, *p_count must contain the
                          entry points's descriptor binding count.
     @param  pp_bindings  If NULL, the entry point's total descriptor binding count
                          will be written to *p_count.
                          If non-NULL, pp_bindings must point to an array with
                          *p_count entries, where pointers to the entry point's
                          descriptor bindings will be written. The caller must not
                          free the binding pointers written to this array.
     @return              If successful, returns SPV_REFLECT_RESULT_SUCCESS.
                          Otherwise, the error code indicates the cause of the
                          failure.

    */
    SpvReflectResult spvReflectEnumerateEntryPointDescriptorBindings(const SpvReflectShaderModule* p_module,
                                                                     const char* entry_point,
                                                                     uint32_t* p_count,
                                                                     SpvReflectDescriptorBinding** pp_bindings);

    /*! @fn spvReflectEnumerateDescriptorSets

     @param  p_module  Pointer to an instance of SpvReflectShaderModule.
     @param  p_count   If pp_sets is NULL, the module's descriptor set
                       count will be stored here.
                       If pp_sets is not NULL, *p_count must contain the
                       module's descriptor set count.
     @param  pp_sets   If NULL, the module's total descriptor set count
                       will be written to *p_count.
                       If non-NULL, pp_sets must point to an array with
                       *p_count entries, where pointers to the module's
                       descriptor sets will be written. The caller must not
                       free the descriptor set pointers written to this array.
     @return           If successful, returns SPV_REFLECT_RESULT_SUCCESS.
                       Otherwise, the error code indicates the cause of the
                       failure.

    */
    SpvReflectResult spvReflectEnumerateDescriptorSets(const SpvReflectShaderModule* p_module, uint32_t* p_count, SpvReflectDescriptorSet** pp_sets);

    /*! @fn spvReflectEnumerateEntryPointDescriptorSets
     @brief  Creates a listing of all descriptor sets and their bindings that are
             used in the static call tree of a given entry point.
     @param  p_module    Pointer to an instance of SpvReflectShaderModule.
     @param  entry_point The name of the entry point to get the descriptor bindings for.
     @param  p_count     If pp_sets is NULL, the module's descriptor set
                         count will be stored here.
                         If pp_sets is not NULL, *p_count must contain the
                         module's descriptor set count.
     @param  pp_sets     If NULL, the module's total descriptor set count
                         will be written to *p_count.
                         If non-NULL, pp_sets must point to an array with
                         *p_count entries, where pointers to the module's
                         descriptor sets will be written. The caller must not
                         free the descriptor set pointers written to this array.
     @return             If successful, returns SPV_REFLECT_RESULT_SUCCESS.
                         Otherwise, the error code indicates the cause of the
                         failure.

    */
    SpvReflectResult spvReflectEnumerateEntryPointDescriptorSets(const SpvReflectShaderModule* p_module,
                                                                 const char* entry_point,
                                                                 uint32_t* p_count,
                                                                 SpvReflectDescriptorSet** pp_sets);


    /*! @fn spvReflectEnumerateInputVariables
     @brief  If the module contains multiple entry points, this will only get
             the input variables for the first one.
     @param  p_module      Pointer to an instance of SpvReflectShaderModule.
     @param  p_count       If pp_variables is NULL, the module's input variable
                           count will be stored here.
                           If pp_variables is not NULL, *p_count must contain
                           the module's input variable count.
     @param  pp_variables  If NULL, the module's input variable count will be
                           written to *p_count.
                           If non-NULL, pp_variables must point to an array with
                           *p_count entries, where pointers to the module's
                           input variables will be written. The caller must not
                           free the interface variables written to this array.
     @return               If successful, returns SPV_REFLECT_RESULT_SUCCESS.
                           Otherwise, the error code indicates the cause of the
                           failure.

    */
    SpvReflectResult spvReflectEnumerateInputVariables(const SpvReflectShaderModule* p_module, uint32_t* p_count, SpvReflectInterfaceVariable** pp_variables);

    /*! @fn spvReflectEnumerateEntryPointInputVariables
     @brief  Enumerate the input variables for a given entry point.
     @param  entry_point The name of the entry point to get the input variables for.
     @param  p_module      Pointer to an instance of SpvReflectShaderModule.
     @param  p_count       If pp_variables is NULL, the entry point's input variable
                           count will be stored here.
                           If pp_variables is not NULL, *p_count must contain
                           the entry point's input variable count.
     @param  pp_variables  If NULL, the entry point's input variable count will be
                           written to *p_count.
                           If non-NULL, pp_variables must point to an array with
                           *p_count entries, where pointers to the entry point's
                           input variables will be written. The caller must not
                           free the interface variables written to this array.
     @return               If successful, returns SPV_REFLECT_RESULT_SUCCESS.
                           Otherwise, the error code indicates the cause of the
                           failure.

    */
    SpvReflectResult spvReflectEnumerateEntryPointInputVariables(const SpvReflectShaderModule* p_module,
                                                                 const char* entry_point,
                                                                 uint32_t* p_count,
                                                                 SpvReflectInterfaceVariable** pp_variables);


    /*! @fn spvReflectEnumerateOutputVariables
     @brief  Note: If the module contains multiple entry points, this will only get
             the output variables for the first one.
     @param  p_module      Pointer to an instance of SpvReflectShaderModule.
     @param  p_count       If pp_variables is NULL, the module's output variable
                           count will be stored here.
                           If pp_variables is not NULL, *p_count must contain
                           the module's output variable count.
     @param  pp_variables  If NULL, the module's output variable count will be
                           written to *p_count.
                           If non-NULL, pp_variables must point to an array with
                           *p_count entries, where pointers to the module's
                           output variables will be written. The caller must not
                           free the interface variables written to this array.
     @return               If successful, returns SPV_REFLECT_RESULT_SUCCESS.
                           Otherwise, the error code indicates the cause of the
                           failure.

    */
    SpvReflectResult spvReflectEnumerateOutputVariables(const SpvReflectShaderModule* p_module, uint32_t* p_count, SpvReflectInterfaceVariable** pp_variables);

    /*! @fn spvReflectEnumerateEntryPointOutputVariables
     @brief  Enumerate the output variables for a given entry point.
     @param  p_module      Pointer to an instance of SpvReflectShaderModule.
     @param  entry_point   The name of the entry point to get the output variables for.
     @param  p_count       If pp_variables is NULL, the entry point's output variable
                           count will be stored here.
                           If pp_variables is not NULL, *p_count must contain
                           the entry point's output variable count.
     @param  pp_variables  If NULL, the entry point's output variable count will be
                           written to *p_count.
                           If non-NULL, pp_variables must point to an array with
                           *p_count entries, where pointers to the entry point's
                           output variables will be written. The caller must not
                           free the interface variables written to this array.
     @return               If successful, returns SPV_REFLECT_RESULT_SUCCESS.
                           Otherwise, the error code indicates the cause of the
                           failure.

    */
    SpvReflectResult spvReflectEnumerateEntryPointOutputVariables(const SpvReflectShaderModule* p_module,
                                                                  const char* entry_point,
                                                                  uint32_t* p_count,
                                                                  SpvReflectInterfaceVariable** pp_variables);


    /*! @fn spvReflectEnumeratePushConstantBlocks
     @brief  Note: If the module contains multiple entry points, this will only get
             the push constant blocks for the first one.
     @param  p_module   Pointer to an instance of SpvReflectShaderModule.
     @param  p_count    If pp_blocks is NULL, the module's push constant
                        block count will be stored here.
                        If pp_blocks is not NULL, *p_count must
                        contain the module's push constant block count.
     @param  pp_blocks  If NULL, the module's push constant block count
                        will be written to *p_count.
                        If non-NULL, pp_blocks must point to an
                        array with *p_count entries, where pointers to
                        the module's push constant blocks will be written.
                        The caller must not free the block variables written
                        to this array.
     @return            If successful, returns SPV_REFLECT_RESULT_SUCCESS.
                        Otherwise, the error code indicates the cause of the
                        failure.

    */
    SpvReflectResult spvReflectEnumeratePushConstantBlocks(const SpvReflectShaderModule* p_module, uint32_t* p_count, SpvReflectBlockVariable** pp_blocks);
    SPV_REFLECT_DEPRECATED("renamed to spvReflectEnumeratePushConstantBlocks")
    SpvReflectResult spvReflectEnumeratePushConstants(const SpvReflectShaderModule* p_module, uint32_t* p_count, SpvReflectBlockVariable** pp_blocks);

    /*! @fn spvReflectEnumerateEntryPointPushConstantBlocks
     @brief  Enumerate the push constant blocks used in the static call tree of a
             given entry point.
     @param  p_module   Pointer to an instance of SpvReflectShaderModule.
     @param  p_count    If pp_blocks is NULL, the entry point's push constant
                        block count will be stored here.
                        If pp_blocks is not NULL, *p_count must
                        contain the entry point's push constant block count.
     @param  pp_blocks  If NULL, the entry point's push constant block count
                        will be written to *p_count.
                        If non-NULL, pp_blocks must point to an
                        array with *p_count entries, where pointers to
                        the entry point's push constant blocks will be written.
                        The caller must not free the block variables written
                        to this array.
     @return            If successful, returns SPV_REFLECT_RESULT_SUCCESS.
                        Otherwise, the error code indicates the cause of the
                        failure.

    */
    SpvReflectResult spvReflectEnumerateEntryPointPushConstantBlocks(const SpvReflectShaderModule* p_module,
                                                                     const char* entry_point,
                                                                     uint32_t* p_count,
                                                                     SpvReflectBlockVariable** pp_blocks);


    /*! @fn spvReflectGetDescriptorBinding

     @param  p_module        Pointer to an instance of SpvReflectShaderModule.
     @param  binding_number  The "binding" value of the requested descriptor
                             binding.
     @param  set_number      The "set" value of the requested descriptor binding.
     @param  p_result        If successful, SPV_REFLECT_RESULT_SUCCESS will be
                             written to *p_result. Otherwise, a error code
                             indicating the cause of the failure will be stored
                             here.
     @return                 If the module contains a descriptor binding that
                             matches the provided [binding_number, set_number]
                             values, a pointer to that binding is returned. The
                             caller must not free this pointer.
                             If no match can be found, or if an unrelated error
                             occurs, the return value will be NULL. Detailed
                             error results are written to *pResult.
    @note                    If the module contains multiple desriptor bindings
                             with the same set and binding numbers, there are
                             no guarantees about which binding will be returned.

    */
    const SpvReflectDescriptorBinding* spvReflectGetDescriptorBinding(const SpvReflectShaderModule* p_module,
                                                                      uint32_t binding_number,
                                                                      uint32_t set_number,
                                                                      SpvReflectResult* p_result);

    /*! @fn spvReflectGetEntryPointDescriptorBinding
     @brief  Get the descriptor binding with the given binding number and set
             number that is used in the static call tree of a certain entry
             point.
     @param  p_module        Pointer to an instance of SpvReflectShaderModule.
     @param  entry_point     The entry point to get the binding from.
     @param  binding_number  The "binding" value of the requested descriptor
                             binding.
     @param  set_number      The "set" value of the requested descriptor binding.
     @param  p_result        If successful, SPV_REFLECT_RESULT_SUCCESS will be
                             written to *p_result. Otherwise, a error code
                             indicating the cause of the failure will be stored
                             here.
     @return                 If the entry point contains a descriptor binding that
                             matches the provided [binding_number, set_number]
                             values, a pointer to that binding is returned. The
                             caller must not free this pointer.
                             If no match can be found, or if an unrelated error
                             occurs, the return value will be NULL. Detailed
                             error results are written to *pResult.
    @note                    If the entry point contains multiple desriptor bindings
                             with the same set and binding numbers, there are
                             no guarantees about which binding will be returned.

    */
    const SpvReflectDescriptorBinding* spvReflectGetEntryPointDescriptorBinding(
        const SpvReflectShaderModule* p_module, const char* entry_point, uint32_t binding_number, uint32_t set_number, SpvReflectResult* p_result);


    /*! @fn spvReflectGetDescriptorSet

     @param  p_module    Pointer to an instance of SpvReflectShaderModule.
     @param  set_number  The "set" value of the requested descriptor set.
     @param  p_result    If successful, SPV_REFLECT_RESULT_SUCCESS will be
                         written to *p_result. Otherwise, a error code
                         indicating the cause of the failure will be stored
                         here.
     @return             If the module contains a descriptor set with the
                         provided set_number, a pointer to that set is
                         returned. The caller must not free this pointer.
                         If no match can be found, or if an unrelated error
                         occurs, the return value will be NULL. Detailed
                         error results are written to *pResult.

    */
    const SpvReflectDescriptorSet* spvReflectGetDescriptorSet(const SpvReflectShaderModule* p_module, uint32_t set_number, SpvReflectResult* p_result);

    /*! @fn spvReflectGetEntryPointDescriptorSet

     @param  p_module    Pointer to an instance of SpvReflectShaderModule.
     @param  entry_point The entry point to get the descriptor set from.
     @param  set_number  The "set" value of the requested descriptor set.
     @param  p_result    If successful, SPV_REFLECT_RESULT_SUCCESS will be
                         written to *p_result. Otherwise, a error code
                         indicating the cause of the failure will be stored
                         here.
     @return             If the entry point contains a descriptor set with the
                         provided set_number, a pointer to that set is
                         returned. The caller must not free this pointer.
                         If no match can be found, or if an unrelated error
                         occurs, the return value will be NULL. Detailed
                         error results are written to *pResult.

    */
    const SpvReflectDescriptorSet* spvReflectGetEntryPointDescriptorSet(const SpvReflectShaderModule* p_module,
                                                                        const char* entry_point,
                                                                        uint32_t set_number,
                                                                        SpvReflectResult* p_result);


    /* @fn spvReflectGetInputVariableByLocation

     @param  p_module  Pointer to an instance of SpvReflectShaderModule.
     @param  location  The "location" value of the requested input variable.
                       A location of 0xFFFFFFFF will always return NULL
                       with *p_result == ELEMENT_NOT_FOUND.
     @param  p_result  If successful, SPV_REFLECT_RESULT_SUCCESS will be
                       written to *p_result. Otherwise, a error code
                       indicating the cause of the failure will be stored
                       here.
     @return           If the module contains an input interface variable
                       with the provided location value, a pointer to that
                       variable is returned. The caller must not free this
                       pointer.
                       If no match can be found, or if an unrelated error
                       occurs, the return value will be NULL. Detailed
                       error results are written to *pResult.
    @note

    */
    const SpvReflectInterfaceVariable* spvReflectGetInputVariableByLocation(const SpvReflectShaderModule* p_module, uint32_t location, SpvReflectResult* p_result);
    SPV_REFLECT_DEPRECATED("renamed to spvReflectGetInputVariableByLocation")
    const SpvReflectInterfaceVariable* spvReflectGetInputVariable(const SpvReflectShaderModule* p_module, uint32_t location, SpvReflectResult* p_result);

    /* @fn spvReflectGetEntryPointInputVariableByLocation

     @param  p_module    Pointer to an instance of SpvReflectShaderModule.
     @param  entry_point The entry point to get the input variable from.
     @param  location    The "location" value of the requested input variable.
                         A location of 0xFFFFFFFF will always return NULL
                         with *p_result == ELEMENT_NOT_FOUND.
     @param  p_result    If successful, SPV_REFLECT_RESULT_SUCCESS will be
                         written to *p_result. Otherwise, a error code
                         indicating the cause of the failure will be stored
                         here.
     @return             If the entry point contains an input interface variable
                         with the provided location value, a pointer to that
                         variable is returned. The caller must not free this
                         pointer.
                         If no match can be found, or if an unrelated error
                         occurs, the return value will be NULL. Detailed
                         error results are written to *pResult.
    @note

    */
    const SpvReflectInterfaceVariable* spvReflectGetEntryPointInputVariableByLocation(const SpvReflectShaderModule* p_module,
                                                                                      const char* entry_point,
                                                                                      uint32_t location,
                                                                                      SpvReflectResult* p_result);

    /* @fn spvReflectGetInputVariableBySemantic

     @param  p_module  Pointer to an instance of SpvReflectShaderModule.
     @param  semantic  The "semantic" value of the requested input variable.
                       A semantic of NULL will return NULL.
                       A semantic of "" will always return NULL with
                       *p_result == ELEMENT_NOT_FOUND.
     @param  p_result  If successful, SPV_REFLECT_RESULT_SUCCESS will be
                       written to *p_result. Otherwise, a error code
                       indicating the cause of the failure will be stored
                       here.
     @return           If the module contains an input interface variable
                       with the provided semantic, a pointer to that
                       variable is returned. The caller must not free this
                       pointer.
                       If no match can be found, or if an unrelated error
                       occurs, the return value will be NULL. Detailed
                       error results are written to *pResult.
    @note

    */
    const SpvReflectInterfaceVariable* spvReflectGetInputVariableBySemantic(const SpvReflectShaderModule* p_module, const char* semantic, SpvReflectResult* p_result);

    /* @fn spvReflectGetEntryPointInputVariableBySemantic

     @param  p_module  Pointer to an instance of SpvReflectShaderModule.
     @param  entry_point The entry point to get the input variable from.
     @param  semantic  The "semantic" value of the requested input variable.
                       A semantic of NULL will return NULL.
                       A semantic of "" will always return NULL with
                       *p_result == ELEMENT_NOT_FOUND.
     @param  p_result  If successful, SPV_REFLECT_RESULT_SUCCESS will be
                       written to *p_result. Otherwise, a error code
                       indicating the cause of the failure will be stored
                       here.
     @return           If the entry point contains an input interface variable
                       with the provided semantic, a pointer to that
                       variable is returned. The caller must not free this
                       pointer.
                       If no match can be found, or if an unrelated error
                       occurs, the return value will be NULL. Detailed
                       error results are written to *pResult.
    @note

    */
    const SpvReflectInterfaceVariable* spvReflectGetEntryPointInputVariableBySemantic(const SpvReflectShaderModule* p_module,
                                                                                      const char* entry_point,
                                                                                      const char* semantic,
                                                                                      SpvReflectResult* p_result);

    /* @fn spvReflectGetOutputVariableByLocation

     @param  p_module  Pointer to an instance of SpvReflectShaderModule.
     @param  location  The "location" value of the requested output variable.
                       A location of 0xFFFFFFFF will always return NULL
                       with *p_result == ELEMENT_NOT_FOUND.
     @param  p_result  If successful, SPV_REFLECT_RESULT_SUCCESS will be
                       written to *p_result. Otherwise, a error code
                       indicating the cause of the failure will be stored
                       here.
     @return           If the module contains an output interface variable
                       with the provided location value, a pointer to that
                       variable is returned. The caller must not free this
                       pointer.
                       If no match can be found, or if an unrelated error
                       occurs, the return value will be NULL. Detailed
                       error results are written to *pResult.
    @note

    */
    const SpvReflectInterfaceVariable* spvReflectGetOutputVariableByLocation(const SpvReflectShaderModule* p_module, uint32_t location, SpvReflectResult* p_result);
    SPV_REFLECT_DEPRECATED("renamed to spvReflectGetOutputVariableByLocation")
    const SpvReflectInterfaceVariable* spvReflectGetOutputVariable(const SpvReflectShaderModule* p_module, uint32_t location, SpvReflectResult* p_result);

    /* @fn spvReflectGetEntryPointOutputVariableByLocation

     @param  p_module     Pointer to an instance of SpvReflectShaderModule.
     @param  entry_point  The entry point to get the output variable from.
     @param  location     The "location" value of the requested output variable.
                          A location of 0xFFFFFFFF will always return NULL
                          with *p_result == ELEMENT_NOT_FOUND.
     @param  p_result     If successful, SPV_REFLECT_RESULT_SUCCESS will be
                          written to *p_result. Otherwise, a error code
                          indicating the cause of the failure will be stored
                          here.
     @return              If the entry point contains an output interface variable
                          with the provided location value, a pointer to that
                          variable is returned. The caller must not free this
                          pointer.
                          If no match can be found, or if an unrelated error
                          occurs, the return value will be NULL. Detailed
                          error results are written to *pResult.
    @note

    */
    const SpvReflectInterfaceVariable* spvReflectGetEntryPointOutputVariableByLocation(const SpvReflectShaderModule* p_module,
                                                                                       const char* entry_point,
                                                                                       uint32_t location,
                                                                                       SpvReflectResult* p_result);

    /* @fn spvReflectGetOutputVariableBySemantic

     @param  p_module  Pointer to an instance of SpvReflectShaderModule.
     @param  semantic  The "semantic" value of the requested output variable.
                       A semantic of NULL will return NULL.
                       A semantic of "" will always return NULL with
                       *p_result == ELEMENT_NOT_FOUND.
     @param  p_result  If successful, SPV_REFLECT_RESULT_SUCCESS will be
                       written to *p_result. Otherwise, a error code
                       indicating the cause of the failure will be stored
                       here.
     @return           If the module contains an output interface variable
                       with the provided semantic, a pointer to that
                       variable is returned. The caller must not free this
                       pointer.
                       If no match can be found, or if an unrelated error
                       occurs, the return value will be NULL. Detailed
                       error results are written to *pResult.
    @note

    */
    const SpvReflectInterfaceVariable* spvReflectGetOutputVariableBySemantic(const SpvReflectShaderModule* p_module, const char* semantic, SpvReflectResult* p_result);

    /* @fn spvReflectGetEntryPointOutputVariableBySemantic

     @param  p_module  Pointer to an instance of SpvReflectShaderModule.
     @param  entry_point  The entry point to get the output variable from.
     @param  semantic  The "semantic" value of the requested output variable.
                       A semantic of NULL will return NULL.
                       A semantic of "" will always return NULL with
                       *p_result == ELEMENT_NOT_FOUND.
     @param  p_result  If successful, SPV_REFLECT_RESULT_SUCCESS will be
                       written to *p_result. Otherwise, a error code
                       indicating the cause of the failure will be stored
                       here.
     @return           If the entry point contains an output interface variable
                       with the provided semantic, a pointer to that
                       variable is returned. The caller must not free this
                       pointer.
                       If no match can be found, or if an unrelated error
                       occurs, the return value will be NULL. Detailed
                       error results are written to *pResult.
    @note

    */
    const SpvReflectInterfaceVariable* spvReflectGetEntryPointOutputVariableBySemantic(const SpvReflectShaderModule* p_module,
                                                                                       const char* entry_point,
                                                                                       const char* semantic,
                                                                                       SpvReflectResult* p_result);

    /*! @fn spvReflectGetPushConstantBlock

     @param  p_module  Pointer to an instance of SpvReflectShaderModule.
     @param  index     The index of the desired block within the module's
                       array of push constant blocks.
     @param  p_result  If successful, SPV_REFLECT_RESULT_SUCCESS will be
                       written to *p_result. Otherwise, a error code
                       indicating the cause of the failure will be stored
                       here.
     @return           If the provided index is within range, a pointer to
                       the corresponding push constant block is returned.
                       The caller must not free this pointer.
                       If no match can be found, or if an unrelated error
                       occurs, the return value will be NULL. Detailed
                       error results are written to *pResult.

    */
    const SpvReflectBlockVariable* spvReflectGetPushConstantBlock(const SpvReflectShaderModule* p_module, uint32_t index, SpvReflectResult* p_result);
    SPV_REFLECT_DEPRECATED("renamed to spvReflectGetPushConstantBlock")
    const SpvReflectBlockVariable* spvReflectGetPushConstant(const SpvReflectShaderModule* p_module, uint32_t index, SpvReflectResult* p_result);

    /*! @fn spvReflectGetEntryPointPushConstantBlock
     @brief  Get the push constant block corresponding to the given entry point.
             As by the Vulkan specification there can be no more than one push
             constant block used by a given entry point, so if there is one it will
             be returned, otherwise NULL will be returned.
     @param  p_module     Pointer to an instance of SpvReflectShaderModule.
     @param  entry_point  The entry point to get the push constant block from.
     @param  p_result     If successful, SPV_REFLECT_RESULT_SUCCESS will be
                          written to *p_result. Otherwise, a error code
                          indicating the cause of the failure will be stored
                          here.
     @return              If the provided index is within range, a pointer to
                          the corresponding push constant block is returned.
                          The caller must not free this pointer.
                          If no match can be found, or if an unrelated error
                          occurs, the return value will be NULL. Detailed
                          error results are written to *pResult.

    */
    const SpvReflectBlockVariable* spvReflectGetEntryPointPushConstantBlock(const SpvReflectShaderModule* p_module, const char* entry_point, SpvReflectResult* p_result);


    /*! @fn spvReflectChangeDescriptorBindingNumbers
     @brief  Assign new set and/or binding numbers to a descriptor binding.
             In addition to updating the reflection data, this function modifies
             the underlying SPIR-V bytecode. The updated code can be retrieved
             with spvReflectGetCode().  If the binding is used in multiple
             entry points within the module, it will be changed in all of them.
     @param  p_module            Pointer to an instance of SpvReflectShaderModule.
     @param  p_binding           Pointer to the descriptor binding to modify.
     @param  new_binding_number  The new binding number to assign to the
                                 provided descriptor binding.
                                 To leave the binding number unchanged, pass
                                 SPV_REFLECT_BINDING_NUMBER_DONT_CHANGE.
     @param  new_set_number      The new set number to assign to the
                                 provided descriptor binding. Successfully changing
                                 a descriptor binding's set number invalidates all
                                 existing SpvReflectDescriptorBinding and
                                 SpvReflectDescriptorSet pointers from this module.
                                 To leave the set number unchanged, pass
                                 SPV_REFLECT_SET_NUMBER_DONT_CHANGE.
     @return                     If successful, returns SPV_REFLECT_RESULT_SUCCESS.
                                 Otherwise, the error code indicates the cause of
                                 the failure.
    */
    SpvReflectResult spvReflectChangeDescriptorBindingNumbers(SpvReflectShaderModule* p_module,
                                                              const SpvReflectDescriptorBinding* p_binding,
                                                              uint32_t new_binding_number,
                                                              uint32_t new_set_number);
    SPV_REFLECT_DEPRECATED("Renamed to spvReflectChangeDescriptorBindingNumbers")
    SpvReflectResult spvReflectChangeDescriptorBindingNumber(SpvReflectShaderModule* p_module,
                                                             const SpvReflectDescriptorBinding* p_descriptor_binding,
                                                             uint32_t new_binding_number,
                                                             uint32_t optional_new_set_number);

    /*! @fn spvReflectChangeDescriptorSetNumber
     @brief  Assign a new set number to an entire descriptor set (including
             all descriptor bindings in that set).
             In addition to updating the reflection data, this function modifies
             the underlying SPIR-V bytecode. The updated code can be retrieved
             with spvReflectGetCode().  If the descriptor set is used in
             multiple entry points within the module, it will be modified in all
             of them.
     @param  p_module        Pointer to an instance of SpvReflectShaderModule.
     @param  p_set           Pointer to the descriptor binding to modify.
     @param  new_set_number  The new set number to assign to the
                             provided descriptor set, and all its descriptor
                             bindings. Successfully changing a descriptor
                             binding's set number invalidates all existing
                             SpvReflectDescriptorBinding and
                             SpvReflectDescriptorSet pointers from this module.
                             To leave the set number unchanged, pass
                             SPV_REFLECT_SET_NUMBER_DONT_CHANGE.
     @return                 If successful, returns SPV_REFLECT_RESULT_SUCCESS.
                             Otherwise, the error code indicates the cause of
                             the failure.
    */
    SpvReflectResult spvReflectChangeDescriptorSetNumber(SpvReflectShaderModule* p_module, const SpvReflectDescriptorSet* p_set, uint32_t new_set_number);

    /*! @fn spvReflectChangeInputVariableLocation
     @brief  Assign a new location to an input interface variable.
             In addition to updating the reflection data, this function modifies
             the underlying SPIR-V bytecode. The updated code can be retrieved
             with spvReflectGetCode().
             It is the caller's responsibility to avoid assigning the same
             location to multiple input variables.  If the input variable is used
             by multiple entry points in the module, it will be changed in all of
             them.
     @param  p_module          Pointer to an instance of SpvReflectShaderModule.
     @param  p_input_variable  Pointer to the input variable to update.
     @param  new_location      The new location to assign to p_input_variable.
     @return                   If successful, returns SPV_REFLECT_RESULT_SUCCESS.
                               Otherwise, the error code indicates the cause of
                               the failure.

    */
    SpvReflectResult spvReflectChangeInputVariableLocation(SpvReflectShaderModule* p_module, const SpvReflectInterfaceVariable* p_input_variable, uint32_t new_location);


    /*! @fn spvReflectChangeOutputVariableLocation
     @brief  Assign a new location to an output interface variable.
             In addition to updating the reflection data, this function modifies
             the underlying SPIR-V bytecode. The updated code can be retrieved
             with spvReflectGetCode().
             It is the caller's responsibility to avoid assigning the same
             location to multiple output variables.  If the output variable is used
             by multiple entry points in the module, it will be changed in all of
             them.
     @param  p_module          Pointer to an instance of SpvReflectShaderModule.
     @param  p_output_variable  Pointer to the output variable to update.
     @param  new_location      The new location to assign to p_output_variable.
     @return                   If successful, returns SPV_REFLECT_RESULT_SUCCESS.
                               Otherwise, the error code indicates the cause of
                               the failure.

    */
    SpvReflectResult spvReflectChangeOutputVariableLocation(SpvReflectShaderModule* p_module, const SpvReflectInterfaceVariable* p_output_variable, uint32_t new_location);


    /*! @fn spvReflectSourceLanguage

     @param  source_lang  The source language code.
     @return Returns string of source language specified in \a source_lang.
             The caller must not free the memory associated with this string.
    */
    const char* spvReflectSourceLanguage(SpvSourceLanguage source_lang);

#if defined(__cplusplus)
};
#endif

#if defined(__cplusplus)
#include <cstdlib>
#include <string>
#include <vector>

namespace spv_reflect
{
/*! \class ShaderModule

*/
class ShaderModule
{
public:
    ShaderModule();
    ShaderModule(size_t size, const void* p_code);
    ShaderModule(const std::vector<uint8_t>& code);
    ShaderModule(const std::vector<uint32_t>& code);
    ~ShaderModule();

    SpvReflectResult GetResult() const;

    const SpvReflectShaderModule& GetShaderModule() const;

    uint32_t GetCodeSize() const;
    const uint32_t* GetCode() const;

    const char* GetEntryPointName() const;

    const char* GetSourceFile() const;

    uint32_t GetEntryPointCount() const;
    const char* GetEntryPointName(uint32_t index) const;

    SpvReflectShaderStageFlagBits GetShaderStage() const;
    SPV_REFLECT_DEPRECATED("Renamed to GetShaderStage")
    SpvReflectShaderStageFlagBits GetVulkanShaderStage() const { return GetShaderStage(); }

    SpvReflectResult EnumerateDescriptorBindings(uint32_t* p_count, SpvReflectDescriptorBinding** pp_bindings) const;
    SpvReflectResult EnumerateEntryPointDescriptorBindings(const char* entry_point, uint32_t* p_count, SpvReflectDescriptorBinding** pp_bindings) const;
    SpvReflectResult EnumerateDescriptorSets(uint32_t* p_count, SpvReflectDescriptorSet** pp_sets) const;
    SpvReflectResult EnumerateEntryPointDescriptorSets(const char* entry_point, uint32_t* p_count, SpvReflectDescriptorSet** pp_sets) const;
    SpvReflectResult EnumerateInputVariables(uint32_t* p_count, SpvReflectInterfaceVariable** pp_variables) const;
    SpvReflectResult EnumerateEntryPointInputVariables(const char* entry_point, uint32_t* p_count, SpvReflectInterfaceVariable** pp_variables) const;
    SpvReflectResult EnumerateOutputVariables(uint32_t* p_count, SpvReflectInterfaceVariable** pp_variables) const;
    SpvReflectResult EnumerateEntryPointOutputVariables(const char* entry_point, uint32_t* p_count, SpvReflectInterfaceVariable** pp_variables) const;
    SpvReflectResult EnumeratePushConstantBlocks(uint32_t* p_count, SpvReflectBlockVariable** pp_blocks) const;
    SpvReflectResult EnumerateEntryPointPushConstantBlocks(const char* entry_point, uint32_t* p_count, SpvReflectBlockVariable** pp_blocks) const;
    SPV_REFLECT_DEPRECATED("Renamed to EnumeratePushConstantBlocks")
    SpvReflectResult EnumeratePushConstants(uint32_t* p_count, SpvReflectBlockVariable** pp_blocks) const
    {
        return EnumeratePushConstantBlocks(p_count, pp_blocks);
    }

    const SpvReflectDescriptorBinding* GetDescriptorBinding(uint32_t binding_number, uint32_t set_number, SpvReflectResult* p_result = nullptr) const;
    const SpvReflectDescriptorBinding* GetEntryPointDescriptorBinding(const char* entry_point,
                                                                      uint32_t binding_number,
                                                                      uint32_t set_number,
                                                                      SpvReflectResult* p_result = nullptr) const;
    const SpvReflectDescriptorSet* GetDescriptorSet(uint32_t set_number, SpvReflectResult* p_result = nullptr) const;
    const SpvReflectDescriptorSet* GetEntryPointDescriptorSet(const char* entry_point, uint32_t set_number, SpvReflectResult* p_result = nullptr) const;
    const SpvReflectInterfaceVariable* GetInputVariableByLocation(uint32_t location, SpvReflectResult* p_result = nullptr) const;
    SPV_REFLECT_DEPRECATED("Renamed to GetInputVariableByLocation")
    const SpvReflectInterfaceVariable* GetInputVariable(uint32_t location, SpvReflectResult* p_result = nullptr) const
    {
        return GetInputVariableByLocation(location, p_result);
    }
    const SpvReflectInterfaceVariable* GetEntryPointInputVariableByLocation(const char* entry_point, uint32_t location, SpvReflectResult* p_result = nullptr) const;
    const SpvReflectInterfaceVariable* GetInputVariableBySemantic(const char* semantic, SpvReflectResult* p_result = nullptr) const;
    const SpvReflectInterfaceVariable* GetEntryPointInputVariableBySemantic(const char* entry_point, const char* semantic, SpvReflectResult* p_result = nullptr) const;
    const SpvReflectInterfaceVariable* GetOutputVariableByLocation(uint32_t location, SpvReflectResult* p_result = nullptr) const;
    SPV_REFLECT_DEPRECATED("Renamed to GetOutputVariableByLocation")
    const SpvReflectInterfaceVariable* GetOutputVariable(uint32_t location, SpvReflectResult* p_result = nullptr) const
    {
        return GetOutputVariableByLocation(location, p_result);
    }
    const SpvReflectInterfaceVariable* GetEntryPointOutputVariableByLocation(const char* entry_point, uint32_t location, SpvReflectResult* p_result = nullptr) const;
    const SpvReflectInterfaceVariable* GetOutputVariableBySemantic(const char* semantic, SpvReflectResult* p_result = nullptr) const;
    const SpvReflectInterfaceVariable* GetEntryPointOutputVariableBySemantic(const char* entry_point, const char* semantic, SpvReflectResult* p_result = nullptr) const;
    const SpvReflectBlockVariable* GetPushConstantBlock(uint32_t index, SpvReflectResult* p_result = nullptr) const;
    SPV_REFLECT_DEPRECATED("Renamed to GetPushConstantBlock")
    const SpvReflectBlockVariable* GetPushConstant(uint32_t index, SpvReflectResult* p_result = nullptr) const
    {
        return GetPushConstantBlock(index, p_result);
    }
    const SpvReflectBlockVariable* GetEntryPointPushConstantBlock(const char* entry_point, SpvReflectResult* p_result = nullptr) const;

    SpvReflectResult ChangeDescriptorBindingNumbers(const SpvReflectDescriptorBinding* p_binding,
                                                    uint32_t new_binding_number = SPV_REFLECT_BINDING_NUMBER_DONT_CHANGE,
                                                    uint32_t optional_new_set_number = SPV_REFLECT_SET_NUMBER_DONT_CHANGE);
    SPV_REFLECT_DEPRECATED("Renamed to ChangeDescriptorBindingNumbers")
    SpvReflectResult ChangeDescriptorBindingNumber(const SpvReflectDescriptorBinding* p_binding,
                                                   uint32_t new_binding_number = SPV_REFLECT_BINDING_NUMBER_DONT_CHANGE,
                                                   uint32_t new_set_number = SPV_REFLECT_SET_NUMBER_DONT_CHANGE)
    {
        return ChangeDescriptorBindingNumbers(p_binding, new_binding_number, new_set_number);
    }
    SpvReflectResult ChangeDescriptorSetNumber(const SpvReflectDescriptorSet* p_set, uint32_t new_set_number = SPV_REFLECT_SET_NUMBER_DONT_CHANGE);
    SpvReflectResult ChangeInputVariableLocation(const SpvReflectInterfaceVariable* p_input_variable, uint32_t new_location);
    SpvReflectResult ChangeOutputVariableLocation(const SpvReflectInterfaceVariable* p_output_variable, uint32_t new_location);

private:
    mutable SpvReflectResult m_result = SPV_REFLECT_RESULT_NOT_READY;
    SpvReflectShaderModule m_module = {};
};


// =================================================================================================
// ShaderModule
// =================================================================================================

/*! @fn ShaderModule

*/
inline ShaderModule::ShaderModule() {}


/*! @fn ShaderModule

  @param  size
  @param  p_code

*/
inline ShaderModule::ShaderModule(size_t size, const void* p_code) { m_result = spvReflectCreateShaderModule(size, p_code, &m_module); }

/*! @fn ShaderModule

  @param  code

*/
inline ShaderModule::ShaderModule(const std::vector<uint8_t>& code) { m_result = spvReflectCreateShaderModule(code.size(), code.data(), &m_module); }

/*! @fn ShaderModule

  @param  code

*/
inline ShaderModule::ShaderModule(const std::vector<uint32_t>& code)
{
    m_result = spvReflectCreateShaderModule(code.size() * sizeof(uint32_t), code.data(), &m_module);
}

/*! @fn  ~ShaderModule

*/
inline ShaderModule::~ShaderModule() { spvReflectDestroyShaderModule(&m_module); }


/*! @fn GetResult

  @return

*/
inline SpvReflectResult ShaderModule::GetResult() const { return m_result; }


/*! @fn GetShaderModule

  @return

*/
inline const SpvReflectShaderModule& ShaderModule::GetShaderModule() const { return m_module; }


/*! @fn GetCodeSize

  @return

  */
inline uint32_t ShaderModule::GetCodeSize() const { return spvReflectGetCodeSize(&m_module); }


/*! @fn GetCode

  @return

*/
inline const uint32_t* ShaderModule::GetCode() const { return spvReflectGetCode(&m_module); }


/*! @fn GetEntryPoint

  @return Returns entry point

*/
inline const char* ShaderModule::GetEntryPointName() const { return this->GetEntryPointName(0); }

/*! @fn GetEntryPoint

  @return Returns entry point

*/
inline const char* ShaderModule::GetSourceFile() const { return m_module.source_file; }

/*! @fn GetEntryPointCount

  @param
  @return
*/
inline uint32_t ShaderModule::GetEntryPointCount() const { return m_module.entry_point_count; }

/*! @fn GetEntryPointName

  @param index
  @return
*/
inline const char* ShaderModule::GetEntryPointName(uint32_t index) const { return m_module.entry_points[index].name; }

/*! @fn GetShaderStage

  @return Returns Vulkan shader stage

*/
inline SpvReflectShaderStageFlagBits ShaderModule::GetShaderStage() const { return m_module.shader_stage; }

/*! @fn EnumerateDescriptorBindings

  @param  count
  @param  p_binding_numbers
  @param  pp_bindings
  @return

*/
inline SpvReflectResult ShaderModule::EnumerateDescriptorBindings(uint32_t* p_count, SpvReflectDescriptorBinding** pp_bindings) const
{
    m_result = spvReflectEnumerateDescriptorBindings(&m_module, p_count, pp_bindings);
    return m_result;
}

/*! @fn EnumerateEntryPointDescriptorBindings

  @param  entry_point
  @param  count
  @param  pp_bindings
  @return

*/
inline SpvReflectResult ShaderModule::EnumerateEntryPointDescriptorBindings(const char* entry_point, uint32_t* p_count, SpvReflectDescriptorBinding** pp_bindings) const
{
    m_result = spvReflectEnumerateEntryPointDescriptorBindings(&m_module, entry_point, p_count, pp_bindings);
    return m_result;
}


/*! @fn EnumerateDescriptorSets

  @param  count
  @param  pp_sets
  @return

*/
inline SpvReflectResult ShaderModule::EnumerateDescriptorSets(uint32_t* p_count, SpvReflectDescriptorSet** pp_sets) const
{
    m_result = spvReflectEnumerateDescriptorSets(&m_module, p_count, pp_sets);
    return m_result;
}

/*! @fn EnumerateEntryPointDescriptorSets

  @param  entry_point
  @param  count
  @param  pp_sets
  @return

*/
inline SpvReflectResult ShaderModule::EnumerateEntryPointDescriptorSets(const char* entry_point, uint32_t* p_count, SpvReflectDescriptorSet** pp_sets) const
{
    m_result = spvReflectEnumerateEntryPointDescriptorSets(&m_module, entry_point, p_count, pp_sets);
    return m_result;
}


/*! @fn EnumerateInputVariables

  @param  count
  @param  pp_variables
  @return

*/
inline SpvReflectResult ShaderModule::EnumerateInputVariables(uint32_t* p_count, SpvReflectInterfaceVariable** pp_variables) const
{
    m_result = spvReflectEnumerateInputVariables(&m_module, p_count, pp_variables);
    return m_result;
}

/*! @fn EnumerateEntryPointInputVariables

  @param  entry_point
  @param  count
  @param  pp_variables
  @return

*/
inline SpvReflectResult ShaderModule::EnumerateEntryPointInputVariables(const char* entry_point, uint32_t* p_count, SpvReflectInterfaceVariable** pp_variables) const
{
    m_result = spvReflectEnumerateEntryPointInputVariables(&m_module, entry_point, p_count, pp_variables);
    return m_result;
}


/*! @fn EnumerateOutputVariables

  @param  count
  @param  pp_variables
  @return

*/
inline SpvReflectResult ShaderModule::EnumerateOutputVariables(uint32_t* p_count, SpvReflectInterfaceVariable** pp_variables) const
{
    m_result = spvReflectEnumerateOutputVariables(&m_module, p_count, pp_variables);
    return m_result;
}

/*! @fn EnumerateEntryPointOutputVariables

  @param  entry_point
  @param  count
  @param  pp_variables
  @return

*/
inline SpvReflectResult ShaderModule::EnumerateEntryPointOutputVariables(const char* entry_point, uint32_t* p_count, SpvReflectInterfaceVariable** pp_variables) const
{
    m_result = spvReflectEnumerateEntryPointOutputVariables(&m_module, entry_point, p_count, pp_variables);
    return m_result;
}


/*! @fn EnumeratePushConstantBlocks

  @param  count
  @param  pp_blocks
  @return

*/
inline SpvReflectResult ShaderModule::EnumeratePushConstantBlocks(uint32_t* p_count, SpvReflectBlockVariable** pp_blocks) const
{
    m_result = spvReflectEnumeratePushConstantBlocks(&m_module, p_count, pp_blocks);
    return m_result;
}

/*! @fn EnumerateEntryPointPushConstantBlocks

  @param  entry_point
  @param  count
  @param  pp_blocks
  @return

*/
inline SpvReflectResult ShaderModule::EnumerateEntryPointPushConstantBlocks(const char* entry_point, uint32_t* p_count, SpvReflectBlockVariable** pp_blocks) const
{
    m_result = spvReflectEnumerateEntryPointPushConstantBlocks(&m_module, entry_point, p_count, pp_blocks);
    return m_result;
}


/*! @fn GetDescriptorBinding

  @param  binding_number
  @param  set_number
  @param  p_result
  @return

*/
inline const SpvReflectDescriptorBinding* ShaderModule::GetDescriptorBinding(uint32_t binding_number, uint32_t set_number, SpvReflectResult* p_result) const
{
    return spvReflectGetDescriptorBinding(&m_module, binding_number, set_number, p_result);
}

/*! @fn GetEntryPointDescriptorBinding

  @param  entry_point
  @param  binding_number
  @param  set_number
  @param  p_result
  @return

*/
inline const SpvReflectDescriptorBinding* ShaderModule::GetEntryPointDescriptorBinding(const char* entry_point,
                                                                                       uint32_t binding_number,
                                                                                       uint32_t set_number,
                                                                                       SpvReflectResult* p_result) const
{
    return spvReflectGetEntryPointDescriptorBinding(&m_module, entry_point, binding_number, set_number, p_result);
}


/*! @fn GetDescriptorSet

  @param  set_number
  @param  p_result
  @return

*/
inline const SpvReflectDescriptorSet* ShaderModule::GetDescriptorSet(uint32_t set_number, SpvReflectResult* p_result) const
{
    return spvReflectGetDescriptorSet(&m_module, set_number, p_result);
}

/*! @fn GetEntryPointDescriptorSet

  @param  entry_point
  @param  set_number
  @param  p_result
  @return

*/
inline const SpvReflectDescriptorSet* ShaderModule::GetEntryPointDescriptorSet(const char* entry_point, uint32_t set_number, SpvReflectResult* p_result) const
{
    return spvReflectGetEntryPointDescriptorSet(&m_module, entry_point, set_number, p_result);
}


/*! @fn GetInputVariable

  @param  location
  @param  p_result
  @return

*/
inline const SpvReflectInterfaceVariable* ShaderModule::GetInputVariableByLocation(uint32_t location, SpvReflectResult* p_result) const
{
    return spvReflectGetInputVariableByLocation(&m_module, location, p_result);
}
inline const SpvReflectInterfaceVariable* ShaderModule::GetInputVariableBySemantic(const char* semantic, SpvReflectResult* p_result) const
{
    return spvReflectGetInputVariableBySemantic(&m_module, semantic, p_result);
}

/*! @fn GetEntryPointInputVariable

  @param  entry_point
  @param  location
  @param  p_result
  @return

*/
inline const SpvReflectInterfaceVariable* ShaderModule::GetEntryPointInputVariableByLocation(const char* entry_point, uint32_t location, SpvReflectResult* p_result) const
{
    return spvReflectGetEntryPointInputVariableByLocation(&m_module, entry_point, location, p_result);
}
inline const SpvReflectInterfaceVariable* ShaderModule::GetEntryPointInputVariableBySemantic(const char* entry_point, const char* semantic, SpvReflectResult* p_result) const
{
    return spvReflectGetEntryPointInputVariableBySemantic(&m_module, entry_point, semantic, p_result);
}


/*! @fn GetOutputVariable

  @param  location
  @param  p_result
  @return

*/
inline const SpvReflectInterfaceVariable* ShaderModule::GetOutputVariableByLocation(uint32_t location, SpvReflectResult* p_result) const
{
    return spvReflectGetOutputVariableByLocation(&m_module, location, p_result);
}
inline const SpvReflectInterfaceVariable* ShaderModule::GetOutputVariableBySemantic(const char* semantic, SpvReflectResult* p_result) const
{
    return spvReflectGetOutputVariableBySemantic(&m_module, semantic, p_result);
}

/*! @fn GetEntryPointOutputVariable

  @param  entry_point
  @param  location
  @param  p_result
  @return

*/
inline const SpvReflectInterfaceVariable* ShaderModule::GetEntryPointOutputVariableByLocation(const char* entry_point, uint32_t location, SpvReflectResult* p_result) const
{
    return spvReflectGetEntryPointOutputVariableByLocation(&m_module, entry_point, location, p_result);
}
inline const SpvReflectInterfaceVariable* ShaderModule::GetEntryPointOutputVariableBySemantic(const char* entry_point, const char* semantic, SpvReflectResult* p_result) const
{
    return spvReflectGetEntryPointOutputVariableBySemantic(&m_module, entry_point, semantic, p_result);
}


/*! @fn GetPushConstant

  @param  index
  @param  p_result
  @return

*/
inline const SpvReflectBlockVariable* ShaderModule::GetPushConstantBlock(uint32_t index, SpvReflectResult* p_result) const
{
    return spvReflectGetPushConstantBlock(&m_module, index, p_result);
}

/*! @fn GetEntryPointPushConstant

  @param  entry_point
  @param  index
  @param  p_result
  @return

*/
inline const SpvReflectBlockVariable* ShaderModule::GetEntryPointPushConstantBlock(const char* entry_point, SpvReflectResult* p_result) const
{
    return spvReflectGetEntryPointPushConstantBlock(&m_module, entry_point, p_result);
}


/*! @fn ChangeDescriptorBindingNumbers

  @param  p_binding
  @param  new_binding_number
  @param  new_set_number
  @return

*/
inline SpvReflectResult ShaderModule::ChangeDescriptorBindingNumbers(const SpvReflectDescriptorBinding* p_binding, uint32_t new_binding_number, uint32_t new_set_number)
{
    return spvReflectChangeDescriptorBindingNumbers(&m_module, p_binding, new_binding_number, new_set_number);
}


/*! @fn ChangeDescriptorSetNumber

  @param  p_set
  @param  new_set_number
  @return

*/
inline SpvReflectResult ShaderModule::ChangeDescriptorSetNumber(const SpvReflectDescriptorSet* p_set, uint32_t new_set_number)
{
    return spvReflectChangeDescriptorSetNumber(&m_module, p_set, new_set_number);
}


/*! @fn ChangeInputVariableLocation

  @param  p_input_variable
  @param  new_location
  @return

*/
inline SpvReflectResult ShaderModule::ChangeInputVariableLocation(const SpvReflectInterfaceVariable* p_input_variable, uint32_t new_location)
{
    return spvReflectChangeInputVariableLocation(&m_module, p_input_variable, new_location);
}


/*! @fn ChangeOutputVariableLocation

  @param  p_input_variable
  @param  new_location
  @return

*/
inline SpvReflectResult ShaderModule::ChangeOutputVariableLocation(const SpvReflectInterfaceVariable* p_output_variable, uint32_t new_location)
{
    return spvReflectChangeOutputVariableLocation(&m_module, p_output_variable, new_location);
}

} // namespace spv_reflect
#endif // defined(__cplusplus)
#endif // SPIRV_REFLECT_H
